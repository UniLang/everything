􏶞o􏶟
􏷲Finds operations based on search settings􏷱
􏷰Operations can be found based on different search queries depending on the context a caller has or wants to filter on􏷯
􏷞build􏷝􏷞buildfarm􏷝􏷞operations􏷝
􏷤􏷣􏷦com.google.protobuf.Duration􏷥
􏷤􏷣􏷦com.google.protobuf.util.Durations􏷥
􏷤􏷣􏷦io.grpc.Deadline􏷥
􏷤􏷣􏷦java.util.concurrent.TimeUnit􏷥
􏷤􏷣􏷦java.util.Map􏷥
􏷤􏷣􏷦java.util.HashMap􏷥
􏷤􏷣􏷦build.buildfarm.common.grpc.GrpcEndpoint􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.ExecuteRequest􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.ExecutionGrpc􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.RequestMetadata􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.WaitExecutionRequest􏷥
􏷤􏷣􏷦build.buildfarm.common.Time􏷥
􏷤􏷣􏷦build.buildfarm.common.Watcher􏷥
􏷤􏷣􏷦build.buildfarm.common.grpc.GrpcEndpoint􏷥
􏷤􏷣􏷦build.buildfarm.common.grpc.GrpcEndpointHandler􏷥
􏷤􏷣􏷦build.buildfarm.common.grpc.TracingMetadataUtils􏷥
􏷤􏷣􏷦build.buildfarm.instance.Instance􏷥
􏷤􏷣􏷦build.buildfarm.metrics.MetricsPublisher􏷥
􏷤􏷣􏷦com.google.common.util.concurrent.FutureCallback􏷥
􏷤􏷣􏷦com.google.common.util.concurrent.ListenableFuture􏷥
􏷤􏷣􏷦com.google.longrunning.Operation􏷥
􏷤􏷣􏷦com.google.protobuf.util.Durations􏷥
􏷤􏷣􏷦io.grpc.Context􏷥
􏷤􏷣􏷦io.grpc.Status􏷥
􏷤􏷣􏷦io.grpc.stub.ServerCallStreamObserver􏷥
􏷤􏷣􏷦io.grpc.stub.StreamObserver􏷥
􏷤􏷣􏷦java.util.concurrent.CancellationException􏷥
􏷤􏷣􏷦java.util.concurrent.ScheduledExecutorService􏷥
􏷤􏷣􏷦java.util.concurrent.TimeUnit􏷥
􏷤􏷣􏷦java.util.logging.Level􏷥
􏷤􏷣􏷦java.util.logging.Logger􏷥
􏷤􏷣􏷦javax.annotation.Nullable􏷥
􏷤i􏷣􏷦com.google.common.util.concurrent.MoreExecutors.directExecutor􏷥
􏷤􏷣􏷦redis.clients.jedis.Jedis􏷥
􏷤􏷣􏷦redis.clients.jedis.JedisCluster􏷥
􏷤􏷣􏷦redis.clients.jedis.Response􏷥
􏷤􏷣􏷦redis.clients.jedis.ScanParams􏷥
􏷤􏷣􏷦redis.clients.jedis.ScanResult􏷥
􏷤􏷣􏷦java.util.List􏷥
􏷤􏷣􏷦java.util.ArrayList􏷥
􏷤􏷣􏷦com.google.longrunning.Operation􏷥
􏷤􏷣􏷦java.io.IOException􏷥
􏷤􏷣􏷦java.util.Collection􏷥
􏷤􏷣􏷦redis.clients.jedis.Jedis􏷥
􏷤􏷣􏷦redis.clients.jedis.JedisPool􏷥
􏷤􏷣􏷦redis.clients.jedis.JedisCluster􏷥
􏷤􏷣􏷦redis.clients.jedis.ScanParams􏷥
􏷤􏷣􏷦redis.clients.jedis.ScanResult􏷥
􏷤􏷣􏷦com.google.protobuf.util.JsonFormat􏷥
􏷤􏷣􏷦build.buildfarm.v1test.ExecutingOperationMetadata􏷥
􏷤􏷣􏷦build.buildfarm.v1test.QueuedOperationMetadata􏷥
􏷤􏷣􏷦build.buildfarm.v1test.CompletedOperationMetadata􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.RequestMetadata􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.ExecuteOperationMetadata􏷥
􏷤􏷣􏷦com.google.protobuf.InvalidProtocolBufferException􏷥
􏷤􏷣􏷦com.google.rpc.PreconditionFailure􏷥
􏷤􏷣􏷦build.buildfarm.v1test.CompletedOperationMetadata􏷥
􏷤􏷣􏷦build.buildfarm.v1test.CompletedOperationMetadata􏷥
􏷤􏷣􏷦build.buildfarm.v1test.ExecutingOperationMetadata􏷥
􏷤􏷣􏷦build.buildfarm.v1test.OperationTimesBetweenStages􏷥
􏷤􏷣􏷦build.buildfarm.v1test.QueuedOperation􏷥
􏷤􏷣􏷦build.buildfarm.v1test.QueuedOperationMetadata􏷥
􏷤􏷣􏷦build.buildfarm.v1test.StageInformation􏷥
􏷤􏷣􏷦build.buildfarm.v1test.Tree􏷥
􏷤􏷣􏷦build.buildfarm.v1test.WorkerProfileMessage􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Action􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.ActionResult􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Command􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Command.EnvironmentVariable􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Digest􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Directory􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.DirectoryNode􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.ExecuteOperationMetadata􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.ExecuteResponse􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.ExecutedActionMetadata􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.FileNode􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.OutputDirectory􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.OutputFile􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.RequestMetadata􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.ServerCapabilities􏷥
􏷤􏷣􏷦build.buildfarm.instance.Utils􏷥
􏷤􏷣􏷦com.google.protobuf.ByteString􏷥
􏷤􏷣􏷦com.jayway.jsonpath􏷥
􏷤􏷣􏷦com.jayway.jsonpath.JsonPath􏷥
􏷤􏷣􏷦com.jayway.jsonpath.JsonPath.parse􏷥
􏷤􏷣􏷦com.jayway.jsonpath.Criteria.where􏷥
􏷤􏷣􏷦com.jayway.jsonpath.Filter.filter􏷥


􏷐Finds operations based on search settings􏷏
􏶠Operations can be found based on different search queries depending on the context a caller has or wants to filter on􏶡
􏷘+s􏷗􏴅Observers􏴆􏷒find operations􏷑
􏶜􏶝􏷆JedisCluster􏷅􏷄cluster􏷃􏷀an established redis cluster􏶿
􏶜􏶝􏷆Instance􏷅􏷄instance􏷃􏷀an instance is used to get additional information about the operation􏶿
􏶜􏶝􏷆FindOperationsSettings􏷅􏷄settings􏷃􏷀settings on how to find and filter operations􏶿
􏶾FindOperationsResults􏶽􏶼results􏶻􏶺results from searching for operations􏶹
􏶴
    FindOperationsResults results = new FindOperationsResults();
    results.operations = new HashMap<String, EnrichedOperation>();
    
    adjustFilter(settings);
    
    //JedisCluster only supports SCAN commands with MATCH patterns containing hash-tags.
    //This prevents us from using the cluster's SCAN to traverse all of the CAS.  
    //That's why we choose to scan each of the jedisNode's individually.
    cluster.getClusterNodes().values().stream()
        .forEach(
            pool -> {
              try (Jedis node = pool.getResource()) {
                findOperationNode(cluster, node, instance, settings, results);
              }
            });

    return results;
􏶳

􏷐Adjust the user provided filter if needed􏷏
􏶠This is used to ensure certain expectations on particular given filters􏶡
􏷘-s􏷗􏴅Observers􏴆􏷒adjust filter􏷑
􏶜􏶝􏷆FindOperationsSettings􏷅􏷄settings􏷃􏷀settings on how to find and filter operations􏶿
􏶴
    //be generous. if no filter is provided assume the user wants to select all operations instead of no operations
    if (settings.filterPredicate.isEmpty()){
        settings.filterPredicate = "*";
    }
􏶳

􏷐Scan all operation entires on existing Jedis node and keep ones that meet query requirements􏷏
􏶠Results are accumulated onto􏶡
􏷘-s􏷗􏴅Observers􏴆􏷒find operation node􏷑
􏶜􏶝􏷆JedisCluster􏷅􏷄cluster􏷃􏷀an established redis cluster􏶿
􏶜􏶝􏷆Jedis􏷅􏷄node􏷃􏷀a node of the cluster􏶿
􏶜􏶝􏷆Instance􏷅􏷄instance􏷃􏷀an instance is used to get additional information about the operation􏶿
􏶜􏶝􏷆FindOperationsSettings􏷅􏷄settings􏷃􏷀settings on what operations to find and keep􏶿
􏶜􏶝􏷆FindOperationsResults􏷅􏷄results􏷃􏷀accumulating results from performing a search􏶿
􏶴
    // iterate over all operation entries via scanning
    String cursor = "0";
    do {
      List<String> operationKeys = scanOperations(node,cursor,settings);
      collectOperations(cluster, instance, operationKeys, settings.filterPredicate, results);
      
    } while (!cursor.equals("0"));
􏶳

􏷐scan the operations list to obtain operation keys􏷏
􏶠scanning is done incrementally via a cursor􏶡
􏷘-s􏷗􏴅Observers􏴆􏷒scan operations􏷑
􏶜􏶝􏷆Jedis􏷅􏷄node􏷃􏷀a node of the cluster􏶿
􏶜􏶝􏷆String􏷅􏷄cursor􏷃􏷀scan cursor􏶿
􏶜􏶝􏷆FindOperationsSettings􏷅􏷄settings􏷃􏷀settings on how to traverse the Operations􏶿
􏶾List<String>􏶽􏶼operation keys􏶻􏶺resulting operation keys from scanning􏶹
􏶴
    // construct query
    ScanParams params = new ScanParams();
    params.match(settings.operationQuery);
    params.count(settings.scanAmount);
    
    // perform scan iteration
    ScanResult scanResult = node.scan(cursor, params);
    if (scanResult != null) {
        cursor = scanResult.getCursor();
        return scanResult.getResult();
    }
    return new ArrayList<>();
􏶳

􏷐collect operations based on settings􏷏
􏶠populates results􏶡
􏷘-s􏷗􏴅Observers􏴆􏷒collect operations􏷑
􏶜􏶝􏷆JedisCluster􏷅􏷄cluster􏷃􏷀an established redis cluster􏶿
􏶜􏶝􏷆Instance􏷅􏷄instance􏷃􏷀an instance is used to get additional information about the operation􏶿
􏶜􏶝􏷆List<String>􏷅􏷄operation keys􏷃􏷀keys to get operations from􏶿
􏶜􏶝􏷆String􏷅􏷄filter predicate􏷃􏷀the search query used to find particular operations􏶿
􏶜􏶝􏷆FindOperationsResults􏷅􏷄results􏷃􏷀accumulating results from finding operations􏶿
􏶴
    for (String operationKey : operationKeys) {
      EnrichedOperation operation = EnrichedOperationBuilder.build(cluster,instance,operationKey);
      if (shouldKeepOperation(operation,filterPredicate)){
        results.operations.put(operationKey,operation);
      }
    }
􏶳

􏷐whether or not to keep operation based on filter settings􏷏
􏶠true if the operation should be returned. false if it should be ignored􏶡
􏷘-s􏷗􏴅Observers􏴆􏷒should keep operation􏷑
􏶜􏶝􏷆EnrichedOperation􏷅􏷄operation􏷃􏷀the operation to analyze based on filter settings􏶿
􏶜􏶝􏷆String􏷅􏷄filter predicate􏷃􏷀the search query used to find particular operations􏶿
􏶾boolean􏶽􏶼should keep􏶻􏶺whether to keep the operation based on the filter settings􏶹
􏶴
    String json = operation.asJsonString();
    System.out.println(json);
    
    //test the predicate
    try {
        List<Map<String, Object>> matches =  JsonPath.parse(json).read(filterPredicate);
        return !matches.isEmpty();
    }
    catch (Exception e) {
        return false;
    }
􏶳

