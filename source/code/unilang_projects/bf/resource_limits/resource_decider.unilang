􏶞o􏶟
􏷲Decide the resource limitations for a given command􏷱
􏷰platform properties from specified exec_properties are taken into account as well as global buildfarm configuration􏷯
􏷞build􏷝􏷞buildfarm􏷝􏷞worker􏷝

􏷤􏷣􏷦com.google.common.collect.LinkedHashMultimap􏷥
􏷤􏷣􏷦com.google.common.collect.Lists􏷥
􏷤􏷣􏷦com.google.common.collect.SetMultimap􏷥
􏷤􏷣􏷦java.util.List􏷥
􏷤􏷣􏷦build.buildfarm.common.redis.BalancedRedisQueue􏷥
􏷤􏷣􏷦redis.clients.jedis.JedisCluster􏷥
􏷤􏷣􏷦java.util.HashSet􏷥
􏷤􏷣􏷦java.util.Map􏷥
􏷤􏷣􏷦java.util.Set􏷥
􏷤􏷣􏷦com.google.common.collect.ImmutableSet􏷥
􏷤􏷣􏷦com.google.common.collect.ImmutableSetMultimap􏷥
􏷤􏷣􏷦java.util.stream.Collectors􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Command􏷥
􏷤􏷣􏷦build.bazel.remote.execution.v2.Platform.Property􏷥
􏷤􏷣􏷦com.google.common.collect.Iterables􏷥
􏷤􏷣􏷦java.util.Collections􏷥
􏷤􏷣􏷦org.json.simple.parser.JSONParser􏷥
􏷤􏷣􏷦org.json.simple.parser.ParseException􏷥
􏲏􏲐􏲍com.google.common.collect.LinkedHashMultimap􏲎
􏲏􏲐􏲍com.google.common.collect.Lists􏲎
􏲏􏲐􏲍com.google.common.collect.SetMultimap􏲎
􏲏􏲐􏲍java.util.List􏲎
􏲏􏲐􏲍build.buildfarm.common.redis.BalancedRedisQueue􏲎
􏲏􏲐􏲍redis.clients.jedis.JedisCluster􏲎
􏲏􏲐􏲍java.util.HashSet􏲎
􏲏􏲐􏲍java.util.Map􏲎
􏲏􏲐􏲍java.util.Set􏲎
􏲏􏲐􏲍com.google.common.collect.ImmutableSet􏲎
􏲏􏲐􏲍com.google.common.collect.ImmutableSetMultimap􏲎
􏲏􏲐􏲍java.util.stream.Collectors􏲎
􏲏􏲐􏲍build.bazel.remote.execution.v2.Command􏲎
􏲏􏲐􏲍build.bazel.remote.execution.v2.Platform􏲎
􏲏􏲐􏲍build.bazel.remote.execution.v2.Platform.Property􏲎
􏲏􏲐􏲍com.google.common.collect.Iterables􏲎
􏲏􏲐􏲍java.util.Collections􏲎
􏲏􏲐􏲍org.json.simple.parser.JSONParser􏲎
􏲏􏲐􏲍org.json.simple.parser.ParseException􏲎
􏲏􏲐􏲍redis.clients.jedis.JedisCluster􏲎
􏲏􏲐􏲍org.junit.Test􏲎
􏲏􏲐􏲍java.util.List􏲎
􏲏􏲐􏲍java.util.ArrayList􏲎
􏲏􏲐􏲍org.junit.runner.RunWith􏲎
􏲏􏲐􏲍org.junit.runners.JUnit4􏲎
􏲏􏲐􏲍java.lang.Thread􏲎
􏲏􏲐􏲍java.util.concurrent.TimeUnit􏲎
􏲏􏲐􏲍java.lang.RuntimeException􏲎
􏲏􏲐􏲍java.io.IOException􏲎
􏲏􏲐􏲍java.util.function.Supplier􏲎
􏲏􏲐􏲍org.mockito.Mock􏲎
􏲏􏲐􏲍org.mockito.MockitoAnnotations􏲎
􏲏􏲐􏲍java.util.Arrays􏲎
􏲏i􏲐􏲍com.google.common.truth.Truth.assertThat􏲎
􏲏i􏲐􏲍org.mockito.Mockito.eq􏲎
􏲏i􏲐􏲍org.mockito.Mockito.mock􏲎
􏲏i􏲐􏲍org.mockito.Mockito.times􏲎
􏲏i􏲐􏲍org.mockito.Mockito.verify􏲎
􏲏i􏲐􏲍org.mockito.Mockito.when􏲎
􏲏i􏲐􏲍org.mockito.Mockito.any􏲎
􏲏􏲐􏲍java.util.HashSet􏲎
􏲏􏲐􏲍java.util.Map􏲎
􏲏􏲐􏲍java.util.Set􏲎
􏲏􏲐􏲍com.google.common.collect.ImmutableList􏲎
􏲏􏲐􏲍build.buildfarm.common.redis.ProvisionedRedisQueue􏲎
􏲏􏲐􏲍com.google.common.collect.Maps􏲎
􏲏􏲐􏲍com.google.common.collect.HashMultimap􏲎
􏲏􏲐􏲍java.util.stream.Collectors􏲎
􏲏􏲐􏲍com.google.common.collect.SetMultimap􏲎
􏲏􏲐􏲍com.google.common.collect.Multimap􏲎
􏲏􏲐􏲍build.buildfarm.worker.ResourceLimits􏲎
􏲏􏲐􏲍build.buildfarm.worker.ResourceDecider􏲎

􏶨the exec_property and platform property name for setting min cores􏶧
􏶦this is decided between client and server􏶥
􏶘-s􏶙􏶰c􏶯􏶮String􏶭􏶬exec property min cores􏶫􏶪"min-cores"􏶩

􏶨the exec_property and platform property name for setting max cores􏶧
􏶦this is decided between client and server􏶥
􏶘-s􏶙􏶰c􏶯􏶮String􏶭􏶬exec property max cores􏶫􏶪"max-cores"􏶩

􏶨the exec_property and platform property name for providing additional environment variables􏶧
􏶦this is decided between client and server􏶥
􏶘-s􏶙􏶰c􏶯􏶮String􏶭􏶬exec property env vars􏶫􏶪"env-vars"􏶩

􏶨the exec_property and platform property prefix name for providing an additional environment variable􏶧
􏶦this is decided between client and server􏶥
􏶘-s􏶙􏶰c􏶯􏶮String􏶭􏶬exec property env var􏶫􏶪"env-var:"􏶩

􏶨the exec_property and platform property name for indicating whether a user wants to debug the before action state of an execution􏶧
􏶦this is intended to be used interactively to debug remote executions􏶥
􏶘-s􏶙􏶰c􏶯􏶮String􏶭􏶬exec property debug before execution􏶫􏶪"debug-before-execution"􏶩

􏶨the exec_property and platform property name for indicating whether a user wants to get debug information from after the execution􏶧
􏶦this is intended to be used interactively to debug remote executions􏶥
􏶘-s􏶙􏶰c􏶯􏶮String􏶭􏶬exec property debug after execution􏶫􏶪"debug-after-execution"􏶩

􏷐decide resource limitations for the given command􏷏
􏶠platform properties from specified exec_properties are taken into account as well as global buildfarm configuration􏶡
􏷘+s􏷗􏴅Observer􏴆􏷒decide resource limitations􏷑
􏶜􏶝􏷆Command􏷅􏷄command􏷃􏷀the command to decide resource limitations for􏶿
􏶜􏶝􏷆bool􏷅􏷄only multicore tests􏷃􏷀only allow ttests to be multicore􏶿
􏶜􏶝􏷆i􏷅􏷄execute stage width􏷃􏷀the maximum amount of cores available for the operation􏶿
􏶾ResourceLimits􏶽􏶼resource limits􏶻􏶺default resource limits􏶹
􏶴
    ResourceLimits limits = new ResourceLimits();
    
    command.getPlatform().getPropertiesList().forEach((property)-> {
        evaluateProperty(limits,property);
    });
    
    // force limits on non-test actions
    if (onlyMulticoreTests && !commandIsTest(command)){
        limits.cpu.min = 1;
        limits.cpu.max = 1;
    }
    
    // claim core amount according to execute stage width
    limits.cpu.claimed =Math.min(limits.cpu.min, executeStageWidth);
    
    //we choose to resolve variables after the other variable values have been decided
    resolveEnvironmentVariables(limits);
    
    return limits;

􏶳
􏴱test core setting􏴲􏴯regular􏴰
􏲝test that cores can be set􏲞
􏲛cores were not decided as expected􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder()
    .addProperties(Platform.Property.newBuilder()
    .setName("min-cores").setValue("7"))
    .addProperties(Platform.Property.newBuilder()
    .setName("max-cores").setValue("14")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,false,100);
    
    //ASSERT
    assertThat(limits.cpu.min).isEqualTo(7);
    assertThat(limits.cpu.max).isEqualTo(14);
􏴮
􏴱test core setting skipped on nontest􏴲􏴯regular􏴰
􏲝test that cores are skipped􏲞
􏲛cores were not decided as expected􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder()
    .addProperties(Platform.Property.newBuilder()
    .setName("min-cores").setValue("7"))
    .addProperties(Platform.Property.newBuilder()
    .setName("max-cores").setValue("14")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.cpu.min).isEqualTo(1);
    assertThat(limits.cpu.max).isEqualTo(1);
􏴮
􏴱test default environment parse􏴲􏴯regular􏴰
􏲝if the user does not pass extra environment variables via platform properties they appear empty􏲞
􏲛the parsing crashed or did not provide an empty map􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().build();
    
    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.isEmpty()).isTrue();
􏴮
􏴱test empty environment parse􏴲􏴯regular􏴰
􏲝if the user does not pass extra environment variables via platform properties they appear empty􏲞
􏲛the parsing crashed or did not provide an empty map􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.isEmpty()).isTrue();
􏴮
􏴱test single environment parse􏴲􏴯regular􏴰
􏲝if the user passes an extra environment variable via platform properties they should be parsed into the map􏲞
􏲛the parsing crashed or the map was not correctly populated􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("{\"foo\": \"bar\"}")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(1);
    assertThat(limits.extraEnvironmentVariables.containsKey("foo")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("foo")).isEqualTo("bar");
􏴮
􏴱test double environment parse􏴲􏴯regular􏴰
􏲝if the user passes an extra environment variable via platform properties they should be parsed into the map􏲞
􏲛the parsing crashed or the map was not correctly populated􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("{\"foo\": \"bar\", \"baz\": \"qux\"}")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(2);
    assertThat(limits.extraEnvironmentVariables.containsKey("foo")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("foo")).isEqualTo("bar");
    assertThat(limits.extraEnvironmentVariables.containsKey("baz")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("baz")).isEqualTo("qux");
􏴮
􏴱test malformed environment parse􏴲􏴯regular􏴰
􏲝when a user passes malformed json to the extra environment variables, safely ignore it􏲞
􏲛the parsing crashed or the map was not correctly populated􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("{\"foo\": \"bar\", \"baz\": \"qux\"} xxxx")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(0);
􏴮
􏴱test environment mustache resolution􏴲􏴯regular􏴰
􏲝test that environment variables can have their values resolved􏲞
􏲛values were not resolved as expected􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder()
    .addProperties(Platform.Property.newBuilder()
    .setName("min-cores").setValue("7"))
    .addProperties(Platform.Property.newBuilder()
    .setName("max-cores").setValue("14"))
    
    .addProperties(Platform.Property.newBuilder()
    .setName("env-vars")
    .setValue("{\"foo\": \"{{limits.cpu.min}}\", \"bar\": \"{{limits.cpu.max}}\"}")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,false,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(2);
    assertThat(limits.extraEnvironmentVariables.containsKey("foo")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("foo")).isEqualTo("7");
    assertThat(limits.extraEnvironmentVariables.containsKey("bar")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("bar")).isEqualTo("14");
􏴮
􏴱test individual environment var parse􏴲􏴯regular􏴰
􏲝if the user passes an extra individual environment variable via platform properties they should be parsed into the map􏲞
􏲛the parsing was not done correctly and the variable was somehow ignored􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-var:foo")
    .setValue("bar")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(1);
    assertThat(limits.extraEnvironmentVariables.containsKey("foo")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("foo")).isEqualTo("bar");
􏴮
􏴱test two individual environment var parse􏴲􏴯regular􏴰
􏲝if the user passes two extra individual environment variable via platform properties they should be parsed into the map􏲞
􏲛the parsing was not done correctly and the variables were ignored for some reason􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder()
    .addProperties(Platform.Property.newBuilder()
    .setName("env-var:foo").setValue("bar"))
    .addProperties(Platform.Property.newBuilder()
    .setName("env-var:baz").setValue("qux")))
    .build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(2);
    assertThat(limits.extraEnvironmentVariables.containsKey("foo")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("foo")).isEqualTo("bar");
    assertThat(limits.extraEnvironmentVariables.containsKey("baz")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("baz")).isEqualTo("qux");
􏴮
􏴱test empty environment var parse􏴲􏴯regular􏴰
􏲝if the user passes an extra individual environment var with no value, it should still be parsed into the map􏲞
􏲛the parsing was not done correctly and the variable was ignored or the value contents are wrong􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("env-var:foo")
    .setValue("")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.extraEnvironmentVariables.size()).isEqualTo(1);
    assertThat(limits.extraEnvironmentVariables.containsKey("foo")).isTrue();
    assertThat(limits.extraEnvironmentVariables.get("foo")).isEqualTo("");
􏴮
􏴱test debug before parse􏴲􏴯regular􏴰
􏲝we can parse out a positive bool for "before execution debugging"􏲞
􏲛the bool was not parsed as true like we would have expected􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("debug-before-execution")
    .setValue("true")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.debugBeforeExecution).isTrue();
􏴮
􏴱test debug after parse􏴲􏴯regular􏴰
􏲝we can parse out a positive bool for "after execution debugging"􏲞
􏲛the bool was not parsed as true like we would have expected􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("debug-after-execution")
    .setValue("true")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.debugAfterExecution).isTrue();
􏴮
􏴱test invalid debug parse􏴲􏴯regular􏴰
􏲝if we provide an invalid boolean value, it is stored as false􏲞
􏲛the value was not parsed gracefully or was somehow interpreted as true􏲜
􏴭
    //ARRANGE
    Command command = Command.newBuilder().setPlatform(Platform.newBuilder().addProperties(Platform.Property.newBuilder()
    .setName("debug-before-execution")
    .setValue("BAD_FORMAT")
    )).build();

    //ACT
    ResourceLimits limits = ResourceDecider.decideResourceLimitations(command,true,100);
    
    //ASSERT
    assertThat(limits.debugBeforeExecution).isFalse();
􏴮


􏷐evaluate a given platform property of a command and use it to adjust execution settings􏷏
􏶠parses the property key/value and stores them appropriately􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒evaluate property􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to apply changes to􏶿
􏶜􏶝􏷆Property􏷅􏷄property􏷃􏷀the property to store􏶿
􏶴
    //handle cpu properties
    if (property.getName().equals(EXEC_PROPERTY_MIN_CORES)) {
        storeMinCores(limits,property);
    }
    else if (property.getName().equals(EXEC_PROPERTY_MAX_CORES)) {
        storeMaxCores(limits,property);
    }
    
    //handle env properties
    else if (property.getName().equals(EXEC_PROPERTY_ENV_VARS)) {
        storeEnvVars(limits,property);
    }
    else if (property.getName().startsWith(EXEC_PROPERTY_ENV_VAR)){
        storeEnvVar(limits,property);
    }
    
    //handle debug properties
    else if (property.getName().equals(EXEC_PROPERTY_DEBUG_BEFORE_EXECUTION)) {
        storeBeforeExecutionDebug(limits,property);
    }
    else if (property.getName().equals(EXEC_PROPERTY_DEBUG_AFTER_EXECUTION)) {
        storeAfterExecutionDebug(limits,property);
    }
􏶳

􏷐store the property for min cores􏷏
􏶠parses and stores the property􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒store min cores􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to apply changes to􏶿
􏶜􏶝􏷆Property􏷅􏷄property􏷃􏷀the property to store􏶿
􏶴
    limits.cpu.min = Integer.parseInt(property.getValue());
􏶳

􏷐store the property for max cores􏷏
􏶠parses and stores the property􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒store max cores􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to apply changes to􏶿
􏶜􏶝􏷆Property􏷅􏷄property􏷃􏷀the property to store􏶿
􏶴
    limits.cpu.max = Integer.parseInt(property.getValue());
􏶳

􏷐store the property for env vars􏷏
􏶠parses the property as json􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒store env vars􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to apply changes to􏶿
􏶜􏶝􏷆Property􏷅􏷄property􏷃􏷀the property to store􏶿
􏶴
    try {
        JSONParser parser = new JSONParser();
        limits.extraEnvironmentVariables = (Map<String, String>)parser.parse(property.getValue());
    } catch (ParseException pe) {
    }
􏶳

􏷐store the property for an env var􏷏
􏶠parses the property key name for the env var name􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒store env var􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to apply changes to􏶿
􏶜􏶝􏷆Property􏷅􏷄property􏷃􏷀the property to store􏶿
􏶴
    String keyValue[] = property.getName().split(":",2);
    String key = keyValue[1];
    String value = property.getValue();
    limits.extraEnvironmentVariables.put(key,value);
􏶳

􏷐store the property for debugging before an execution􏷏
􏶠parses and stores a boolean􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒store before execution debug􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to apply changes to􏶿
􏶜􏶝􏷆Property􏷅􏷄property􏷃􏷀the property to store􏶿
􏶴
    limits.debugBeforeExecution = Boolean.parseBoolean(property.getValue());
􏶳

􏷐store the property for debugging after an execution􏷏
􏶠parses and stores a boolean􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒store after execution debug􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to apply changes to􏶿
􏶜􏶝􏷆Property􏷅􏷄property􏷃􏷀the property to store􏶿
􏶴
    limits.debugAfterExecution = Boolean.parseBoolean(property.getValue());
􏶳



􏷐resolve any templates found in the env variables􏷏
􏶠this assumes the other values that will be resolving the templates have already been decided􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒resolve environment variables􏷑
􏶜􏶝􏷆ResourceLimits􏷅􏷄limits􏷃􏷀current limits to have resolved􏶿
􏶴
    
    // resolve any template values
    limits.extraEnvironmentVariables.replaceAll((key, val) 
                    -> {
                    val = val.replace("{{limits.cpu.min}}",String.valueOf(limits.cpu.min));
                    val = val.replace("{{limits.cpu.max}}",String.valueOf(limits.cpu.max));
                    val = val.replace("{{limits.cpu.claimed}}",String.valueOf(limits.cpu.claimed));
                    return val;}
                    );
    
􏶳


􏷐derive if command is a test run􏷏
􏶠find a reliable way to identify whether a command is a test or not􏶡
􏷘-s􏷗􏴅Observer􏴆􏷒command is test􏷑
􏶜􏶝􏷆Command􏷅􏷄command􏷃􏷀the command to identify as a test command􏶿
􏶾bool􏶽􏶼exists􏶻􏶺whether the command is a test􏶹
􏶴
    // only tests are setting this currently - other mechanisms are unreliable
    return Iterables.any(
        command.getEnvironmentVariablesList(),
        (envVar) -> envVar.getName().equals("XML_OUTPUT_FILE"));
􏶳


