􏶞g􏶟
􏷲various algorithms for analyzing and lane selecting a route
algorithms decide to make selections based on annotated route information, and provided user data􏷱
􏷰there may be various reasons to select lanes along a route
knowing when to regenerate is one such use case􏷯
􏷮Regeneration􏷭
􏴃Precondition Checks􏴄
􏴁Checks that can be made to verify parameters meet preconditions on various APIs􏴂
􏴃Lane Selection􏴄
􏴁Decide how to select lanes along a route􏴂
􏴃Annotated Route􏴄
􏴁Functionality over event annotated routes􏴂
􏴃String Representations􏴄
􏴁String representations of the event annotated route􏴂
􏷬Trevor Hickey􏷫

􏶔􏶕􏶒hub/base/platform/compiler_specific􏶓
􏶔􏶕􏶒local_map/libs/regeneration/preset_routes􏶓
􏶔s􏶕􏶒algorithm􏶓
􏶔s􏶕􏶒set􏶓
􏶔s􏶕􏶒iostream􏶓
􏶔s􏶕􏶒string􏶓

􏲏􏲐
􏲍local_map/libs/regeneration/preset_routes􏲎

􏷞local_map􏷝􏷞statik􏷝


􏷘+􏷗􏷒precondition select lanes that exceed accumulated distance􏷑
􏴅Precondition Checks􏴆
􏷐Checks whether the arguments are valid as a precondition to the call􏷏
􏶠This function is a predicate for checking all the necessary preconditions􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾bool􏶽􏶼meets preconditions􏶻􏲅true􏲆􏶺whether the arguments meet the implementation's preconditions􏶹
􏶴
    if (HUB_UNLIKELY(!􏵲is positive􏵳distance_m))){
        return false;
    }
􏶳
􏴯positive pass􏴰
􏲝The accumulated distance must be positive.  Zero is not positive􏲞
􏲛Implementation is no longer enforcing positive distance􏲜
􏴭
    //ARRANGE
    route r;
    int distance = 1;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_that_exceed_accumulated_distance(r,distance);
    
    //ASSERT
    EXPECT_TRUE(meets_preconditions);
􏴮
􏴯zero fail􏴰
􏲝The accumulated distance must be positive  Zero is not positive􏲞
􏲛Implementation is no longer enforcing positive distance􏲜
􏴭
    //ARRANGE
    route r;
    int distance = 0;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_that_exceed_accumulated_distance(r,distance);
    
    //ASSERT
    EXPECT_FALSE(meets_preconditions);
􏴮
􏴯negative fail􏴰
􏲝The accumulated distance must be positive  Zero is not positive􏲞
􏲛Implementation is no longer enforcing positive distance􏲜
􏴭
    //ARRANGE
    route r;
    int distance = -1;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_that_exceed_accumulated_distance(r,distance);
    
    //ASSERT
    EXPECT_FALSE(meets_preconditions);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    std::vector<double>                       distances(s.range(0), 10.0f);
    auto                                      route = local_map::statik::create_route_from_lane_distances(distances);
􏱼
􏱹local_map::statik::precondition_select_lanes_that_exceed_accumulated_distance(route,100)􏱺

􏷘+􏷗􏷒precondition select lanes prior to exceeding distance􏷑
􏴅Precondition Checks􏴆
􏷐Checks whether the arguments are valid as a precondition to the call􏷏
􏶠This function is a predicate for checking all the necessary preconditions􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance that must not be exceeded􏶿
􏶚m􏶛􏶾bool􏶽􏶼meets preconditions􏶻􏲅true􏲆􏶺whether the arguments meet the implementation's preconditions􏶹
􏶴
    if (HUB_UNLIKELY(!􏵲is positive􏵳distance_m))){
        return false;
    }
    
    if (HUB_UNLIKELY(!􏵲no lane longer than distance􏵳route,distance_m))){
        return false;
    }
􏶳
􏴯positive_pass􏴰
􏲝The accumulated distance must be positive.  Zero is not positive􏲞
􏲛Implementation is no longer enforcing positive distance􏲜
􏴭
    //ARRANGE
    route r;
    int distance = 1;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_prior_to_exceeding_distance(r,distance);
    
    //ASSERT
    EXPECT_TRUE(meets_preconditions);
􏴮
􏴯zero fail􏴰
􏲝The accumulated distance must be positive  Zero is not positive􏲞
􏲛Implementation is no longer enforcing positive distance􏲜
􏴭
    //ARRANGE
    route r;
    int distance = 0;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_prior_to_exceeding_distance(r,distance);
    
    //ASSERT
    EXPECT_FALSE(meets_preconditions);
􏴮
􏴯negative fail􏴰
􏲝The accumulated distance must be positive  Zero is not positive􏲞
􏲛Implementation is no longer enforcing positive distance􏲜
􏴭
    //ARRANGE
    route r;
    int distance = -1;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_prior_to_exceeding_distance(r,distance);
    
    //ASSERT
    EXPECT_FALSE(meets_preconditions);
􏴮
􏴯lane too long fail􏴰
􏲝We can't select lanes prior to exceeding a distance if the lane itself is longer than the distance􏲞
􏲛Implementation is no longer enforcing that lanes are shorter than provided distance􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({5,5,5,11,5});
    int distance = 10;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_prior_to_exceeding_distance(r,distance);
    
    //ASSERT
    EXPECT_FALSE(meets_preconditions);
􏴮
􏴯lanes small enough pass􏴰
􏲝We can't select lanes prior to exceeding a distance if the lane itself is longer than the distance􏲞
􏲛Implementation is no longer enforcing that lanes are shorter than provided distance􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({5,5,5,5,5});
    int distance = 10;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_prior_to_exceeding_distance(r,distance);
    
    //ASSERT
    EXPECT_TRUE(meets_preconditions);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    std::vector<double>                       distances(s.range(0), 10.0f);
    auto                                      route = local_map::statik::create_route_from_lane_distances(distances);
􏱼
􏱹local_map::statik::precondition_select_lanes_prior_to_exceeding_distance(route,100)􏱺

􏷘+􏷗􏷒precondition select lanes for local map sla requirement􏷑
􏴅Precondition Checks􏴆
􏷐Checks whether the arguments are valid as a precondition to the call􏷏
􏶠This function is a predicate for checking all the necessary preconditions􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to minimally reach􏶿
􏶚m􏶛􏶾bool􏶽􏶼meets preconditions􏶻􏲅true􏲆􏶺whether the arguments meet the implementation's preconditions􏶹
􏶴
    if (HUB_UNLIKELY(!􏵲precondition select lanes that exceed accumulated distance􏵳route,distance_m))){
        return false;
    }
􏶳
􏴯positive_pass􏴰
􏲝The accumulated distance must be positive.  Zero is not positive􏲞
􏲛Implementation is no longer enforcing positive distance􏲜
􏴭
    //ARRANGE
    route r;
    int distance = 1;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_for_local_map_sla_requirement(r,distance);
    
    //ASSERT
    EXPECT_TRUE(meets_preconditions);
􏴮
􏴯zero fail􏴰
􏲝The accumulated distance must be positive  Zero is not positive􏲞
􏲛Implementation is no longer enforcing positive distance􏲜
􏴭
    //ARRANGE
    route r;
    int distance = 0;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_for_local_map_sla_requirement(r,distance);
    
    //ASSERT
    EXPECT_FALSE(meets_preconditions);
􏴮
􏴯negative fail􏴰
􏲝The accumulated distance must be positive  Zero is not positive􏲞
􏲛Implementation is no longer enforcing positive distance􏲜
􏴭
    //ARRANGE
    route r;
    int distance = -1;
    
    //ACT
    auto meets_preconditions = precondition_select_lanes_for_local_map_sla_requirement(r,distance);
    
    //ASSERT
    EXPECT_FALSE(meets_preconditions);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    std::vector<double>                       distances(s.range(0), 10.0f);
    auto                                      route = local_map::statik::create_route_from_lane_distances(distances);
􏱼
􏱹local_map::statik::precondition_select_lanes_for_local_map_sla_requirement(route,100)􏱺


􏷘+􏷗􏷒select lanes􏷑
􏴅Lane Selection􏴆
􏷐select lanes based on the configured selecting strategy􏷏
􏶠This is a frontend for calling the different selecting algorithms
Mainly used for testing􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆marking_input􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄settings􏷃􏷀the selecting strategy to use􏶿
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    if (settings.lane_selection.exceeding_accumulated_distance){
        auto indexes = 􏵲select lanes that exceed accumulated distance􏵳route,settings.lane_selection.exceeding_distance_m,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.before_exceeding_accumulated_distance){
        auto indexes = 􏵲select lanes prior to exceeding accumulated distance􏵳route,settings.lane_selection.before_exceeding_distance_m,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.prior_to_loop){
        auto indexes = 􏵲select lanes prior to forming a submap loop􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.next_unique_submap_in_loop){
        auto indexes = 􏵲select first lane in unique submap after entering loop􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.first_lane_loop){
        auto indexes = 􏵲select first lanes involved in submap loop􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.all_lanes_loop){
        auto indexes = 􏵲select all lanes in entered submap loop􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.after_loop){
        auto indexes = 􏵲select first lane after loop causing submaps􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.after_loop_second){
        auto indexes = 􏵲select second lane after loop causing submaps􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.submap_transition){
        auto indexes = 􏵲select lanes that transition to new submaps􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.first){
        auto indexes = 􏵲select first lane􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.last){
        auto indexes = 􏵲select last lane􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.all){
        auto indexes = 􏵲select all lanes􏵳route,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.specific_lane_index){
        auto indexes = 􏵲select specific lane index􏵳route,settings.placement.lane_index,settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
    if (settings.lane_selection.regen_sla){
        auto indexes = 􏵲select lanes for local map sla requirement􏵳route, settings.lane_selection.sla_distance_m, settings.lane_selection.apply_window);
        􏵲merge􏵳lane_indexes,indexes);
    }
􏶳
􏴯defaults select nothing􏴰
􏲝Using a default route and default settings should execute successfully and select nothing􏲞
􏲛Something has changed in an underlying algorithm resulting in an integration failure􏲜
􏴭
    //ARRANGE
    route r;
    marking_input settings;
    
    //ACT
    auto indexes = select_lanes(r,settings);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯run all selected algorithms􏴰
􏲝Ensure that we can run all of the algorithms that can be selected􏲞
􏲛We were not able to run all of the selected algorithms􏲜
􏴭
    //ARRANGE
    route r;
    marking_input settings;
    settings.lane_selection.exceeding_accumulated_distance = true;
    settings.lane_selection.before_exceeding_accumulated_distance = true;
    settings.lane_selection.prior_to_loop = true;
    settings.lane_selection.next_unique_submap_in_loop = true;
    settings.lane_selection.first_lane_loop = true;
    settings.lane_selection.all_lanes_loop = true;
    settings.lane_selection.after_loop = true;
    settings.lane_selection.after_loop_second = true;
    settings.lane_selection.submap_transition = true;
    settings.lane_selection.first = true;
    settings.lane_selection.last = true;
    settings.lane_selection.all = true;
    settings.lane_selection.specific_lane_index = true;
    settings.lane_selection.regen_sla = true;
    
    //ACT
    auto indexes = select_lanes(r,settings);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯discussion􏴰
􏲝We provide a fake test to discuss the tool that is using this function for integration􏲞
􏲛If the Annotation Tool crashes internally within the API, this is the integration point that should be evaluated and fixed􏲜
􏴭
    // The implementation of this function dispatches to already tested algorithms.
    // The Annotation Tool uses it as an integration point.
    // Any crashes in the tool related to the API can be investigated here.
􏴮
􏱿regular growth on all algorithms􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    
    //enable all algorithms together
    marking_input settings;
    settings.lane_selection.sla_distance_m = 100;
    settings.lane_selection.exceeding_distance_m = 100;
    settings.lane_selection.before_exceeding_distance_m = 100;
    settings.lane_selection.exceeding_accumulated_distance = true;
    settings.lane_selection.before_exceeding_accumulated_distance = true;
    settings.lane_selection.prior_to_loop = true;
    settings.lane_selection.next_unique_submap_in_loop = true;
    settings.lane_selection.first_lane_loop = true;
    settings.lane_selection.all_lanes_loop = true;
    settings.lane_selection.after_loop = true;
    settings.lane_selection.after_loop_second = true;
    settings.lane_selection.submap_transition = true;
    settings.lane_selection.first = true;
    settings.lane_selection.last = true;
    settings.lane_selection.all = true;
    settings.lane_selection.specific_lane_index = true;
    settings.lane_selection.regen_sla = true;
    std::vector<double>                       distances(s.range(0), 10.0f);
    auto                                      route = local_map::statik::create_route_from_lane_distances(distances);
􏱼
􏱹local_map::statik::select_lanes(route,settings)􏱺
􏱿regular growth on all algorithms􏲀􏱽loops􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    
    //enable all algorithms together
    marking_input settings;
    settings.lane_selection.sla_distance_m = 100;
    settings.lane_selection.exceeding_distance_m = 100;
    settings.lane_selection.before_exceeding_distance_m = 100;
    settings.lane_selection.exceeding_accumulated_distance = true;
    settings.lane_selection.before_exceeding_accumulated_distance = true;
    settings.lane_selection.prior_to_loop = true;
    settings.lane_selection.next_unique_submap_in_loop = true;
    settings.lane_selection.first_lane_loop = true;
    settings.lane_selection.all_lanes_loop = true;
    settings.lane_selection.after_loop = true;
    settings.lane_selection.after_loop_second = true;
    settings.lane_selection.submap_transition = true;
    settings.lane_selection.first = true;
    settings.lane_selection.last = true;
    settings.lane_selection.all = true;
    settings.lane_selection.specific_lane_index = true;
    settings.lane_selection.regen_sla = true;
    
    //route with lots of loops
    std::vector<int>                       submap_ids;
    for (size_t i = 0; i < s.range(0); ++i){
        submap_ids.emplace_back(i%2);
    }
    auto                                      route = local_map::statik::create_route_from_submap_ids(submap_ids);
􏱼
􏱹local_map::statik::select_lanes(route,settings)􏱺



􏷘-􏷗􏷒merge􏷑
􏴅Lane Selection􏴆
􏷐merge elements from one set into another􏷏
􏶠ensures that the merged set contains all unique elements between the two sets􏶡
􏷌T􏷋􏷈element of set􏷇
􏶜mr􏶝􏷆set􏷅􏳣T􏳤􏷄to􏷃􏷀the set which will contain all of the unique elements between the two􏶿
􏶜􏶝􏷆set􏷅􏳣T􏳤􏷄from􏷃􏷀the set used to merge into the other􏶿
􏶴
    to.insert(from.begin(), from.end());
􏶳

􏷘-􏷗􏷒merge􏷑
􏴅Lane Selection􏴆
􏷐merge lane selections together􏷏
􏶠ensures no duplicate indexes after merge􏶡
􏶜mr􏶝􏷆route_selections􏷅􏷄to􏷃􏷀the route selections which will contain all of the unique elements between the two􏶿
􏶜􏶝􏷆route_selections􏷅􏷄from􏷃􏷀the route selections used to merge into the other􏶿
􏶴
    // structure to avoid duplicates when merging
    std::unordered_map<size_t,std::set<std::string>> merged_selections;
    auto safe_merge = [&](lane_selection const& selection){
        if (merged_selections.find(selection.index) != merged_selections.end()){
            􏵲merge􏵳merged_selections[selection.index],selection.reason_collection);
        }
        else {
            merged_selections.insert({selection.index,selection.reason_collection});
        }
    };
    
    // merge lane selections
    for (auto const& it: to.lane_sequence){
        safe_merge(it);
    }
    for (auto const& it: from.lane_sequence){
        safe_merge(it);
    }
    
    // adapt existing container
    to.lane_sequence.clear();
    for (auto const& it: merged_selections){
        to.lane_sequence.emplace_back(it.first,it.second);
    }
􏶳

􏷘+􏷗􏷒as lane indexes􏷑
􏴅Lane Selection􏴆
􏷐get the lane selections as a list of lane indexes􏷏
􏶠converts the lane selections to specific lane indexes􏶡
􏶜􏶝􏷆route_selections􏷅􏷄selections􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀selections made over a route􏶿
􏶚m􏶛􏶾ordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lane indexes along the route􏶹
􏶴
    lane_indexes.reserve(selections.lane_sequence.size());
    for (auto const& it: selections.lane_sequence){
        lane_indexes.emplace_back(it.index);
    }
􏶳
􏴯default yields no indexes􏴰
􏲝a default instantiation of route selections yields no indexes􏲞
􏲛for some reason default constructed route selections have lane indexes􏲜
􏴭
    //ARRANGE
    route_selections selections;
    
    //ACT
    auto indexes = as_lane_indexes(selections);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯can get back indexes􏴰
􏲝add selections to the route selections and ensure we get the right lane selections back􏲞
􏲛we did not get back the expected lane indexes􏲜
􏴭
    //ARRANGE
    route_selections selections;
    for (size_t i = 0; i < 10; i+=2){
        selections.lane_sequence.emplace_back(i,std::set<std::string>{"test"});
    }
    
    //ACT
    auto indexes = as_lane_indexes(selections);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),5);
    EXPECT_TRUE(std::find(std::begin(indexes),std::end(indexes),0) != std::end(indexes));
    EXPECT_TRUE(std::find(std::begin(indexes),std::end(indexes),2) != std::end(indexes));
    EXPECT_TRUE(std::find(std::begin(indexes),std::end(indexes),4) != std::end(indexes));
    EXPECT_TRUE(std::find(std::begin(indexes),std::end(indexes),6) != std::end(indexes));
    EXPECT_TRUE(std::find(std::begin(indexes),std::end(indexes),8) != std::end(indexes));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷number of selections􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    local_map::statik::route_selections selections;
    for (size_t i = 0; i < s.range(0); ++i){
        selections.lane_sequence.emplace_back(i,std::set<std::string>{"test"});
    }
􏱼
􏱹local_map::statik::as_lane_indexes(selections)􏱺


􏷘-􏷗􏷒algorithm start􏷑
􏴅Lane Selection􏴆
􏷐decide the starting index for the algorithm to being applying􏷏
􏶠ensures the index is valid for the route given􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route used to check the bounds of the given window􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window used to derive the index􏶿
􏶚m􏶛􏶾size􏶽􏶼algorithm start􏶻􏲅0􏲆􏶺the starting index for the algorithm to being applying􏶹
􏶴
    if (range.start){
        //fitting for safety
        //might consider a non-safe version later
        algorithm_start = 􏵲fitted index for iteration􏵳route,*range.start);
    }
􏶳

􏷘-􏷗􏷒algorithm end􏷑
􏴅Lane Selection􏴆
􏷐decide the ending index for the algorithm to stop applying􏷏
􏶠ensures the index is valid for the route given􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route used to check the bounds of the given window􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window used to derive the index􏶿
􏶚m􏶛􏶾size􏶽􏶼algorithm end􏶻􏲅number_of_lanes(route)􏲆􏶺the ending index for the algorithm to stop applying􏶹
􏶴
    if (range.end){
        //fitting for safety
        //might consider a non-safe version later
        algorithm_end = 􏵲fitted index for iteration􏵳route,*range.end);
    }
􏶳

􏷘-􏷗􏷒fitted index for iteration􏷑
􏴅Lane Selection􏴆
􏷐takes an index and fits it to the particular route so that it would be valid to use when iterating􏷏
􏶠fitting the start and end indexes will ensure no indexing is out of bounds􏶡
􏷌Route􏷋􏷈the route used to fit the index􏷇
􏶜􏶝􏷆Route􏷅􏷄route􏷃􏷀the route used to fit the index􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the index to fit for iteration􏶿
􏶚m􏶛􏶾size􏶽􏶼fitted index􏶻􏲅index􏲆􏶺the fitted index􏶹
􏶴
    if (index < 0){
        fitted_index = 0;
    }
    else if(index > 􏵲number of lanes􏵳route)){
        fitted_index = 􏵲number of lanes􏵳route);
    }
􏶳

􏷘-􏷗􏷒iterate with algorithm window􏷑
􏴅Lane Selection􏴆
􏷐iterate over a route according to the algorithm window, and apply the function on each lane index􏷏
􏶠higher order function for iterating over portions of route􏶡
􏷌Fun􏷋􏷈the function to apply on each iteration􏷇
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to iterate over􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window used to derive index range􏶿
􏶜􏶝􏷆Fun􏷅􏷄fun􏷃􏷀the function to apply on each iteration; typically lambda􏶿
􏶴
    for (size_t i = 􏵲algorithm start􏵳route,range); i < 􏵲algorithm end􏵳route,range); ++i){
        fun(i);
    }
􏶳

􏷘+􏷗􏷒select lanes that exceed accumulated distance􏷑
􏴅Lane Selection􏴆
􏷐select lanes along that route that exceed an accumulated distance greater than the provided distance􏷏
􏶠Ensures the distance is minimally met along each division made on the route􏶡
􏵪distance_must_be_positive()􏵫
􏵨the distance must be positive􏵩
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏲧local_map/libs/submap/submap_identifier􏲨􏲥local_map/libs/submap/local_map_submap􏲦􏷀the distance to minimally reach􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    double total_distance = 0.0;
    􏵲iterate with algorithm window􏵳route,range,[&](size_t i){
        double lane_distance_m = 􏵲lane length􏵳route,i);
        if (total_distance+lane_distance_m > distance_m){
            lane_indexes.insert(i);
            total_distance = 0;
        }
        else{
            total_distance += lane_distance_m;
        }
    });
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto any_valid_distance_m = 1.0;
    auto indexes = select_lanes_that_exceed_accumulated_distance(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯select every lane􏴰
􏲝If every lane exceeds the distance given, all of the lanes should be selected􏲞
􏲛Implementation is no longer handling the exceeded distance check properly􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({100,100,100});
    
    //ACT
    auto distance_m = 50;
    auto indexes = select_lanes_that_exceed_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) != indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
􏴮
􏴯select every other lane􏴰
􏲝If the distance is exceeded every other lane, we should have every other lane selected􏲞
􏲛Implementation is no longer handling the exceeded distance check properly􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({100,100,100,100,100,100});
    
    //ACT
    auto distance_m = 101;
    auto indexes = select_lanes_that_exceed_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) != indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) != indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) != indexes.end());
􏴮
􏴯distance not reached􏴰
􏲝If the distance is never reached along the route, no lanes should be selected􏲞
􏲛Implementation is accidentally selecting lanes before the distance is exceeded along the route􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({25,25,25,25});
    
    //ACT
    auto distance_m = 100;
    auto indexes = select_lanes_that_exceed_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto distance_m = 100;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_lanes_that_exceed_accumulated_distance(r,distance_m);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_lanes_that_exceed_accumulated_distance(r,100)􏱺

􏷘+􏷗􏷒select lanes prior to exceeding accumulated distance􏷑
􏴅Lane Selection􏴆
􏷐select lanes along that route that each division does not exceed the distance given􏷏
􏶠Ensures no division is greater than the distance provided􏶡
􏵪distance_must_be_positive()􏵫
􏵨the distance must be positive􏵩
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏲧local_map/libs/submap/submap_identifier􏲨􏲥local_map/libs/submap/local_map_submap􏲦􏷀the distance that must not be exceeded􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    double total_distance = 0.0;
    􏵲iterate with algorithm window􏵳route,range,[&](size_t i){
        double lane_distance_m = 􏵲lane length􏵳route,i);
        if (total_distance+lane_distance_m > distance_m){
            insert_previous(lane_indexes,i);
            total_distance = lane_distance_m;
        }
        else{
            total_distance += lane_distance_m;
        }
    });
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto any_valid_distance_m = 1.0;
    auto indexes = select_lanes_prior_to_exceeding_accumulated_distance(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯select every lane except last􏴰
􏲝We should be able to select every lane except the last one􏲞
􏲛Implementation is no longer selecting the lanes before the lanes that exceed an accumulated distance􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({100,100,100});
    
    //ACT
    auto distance_m = 50;
    auto indexes = select_lanes_prior_to_exceeding_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),2);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) != indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
􏴮
􏴯select lanes before distance is exceeded􏴰
􏲝We should be able to select only the lanes prior to exceeding an accumulated distance􏲞
􏲛Implementation is no longer selecting the lanes before the lanes that exceed an accumulated distance􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({5,5,5,5,5,5});
    
    //ACT
    auto distance_m = 21;
    auto indexes = select_lanes_prior_to_exceeding_accumulated_distance(r,distance_m);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) != indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) == indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto distance_m = 100;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_lanes_prior_to_exceeding_accumulated_distance(r,distance_m);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_lanes_prior_to_exceeding_accumulated_distance(r,100)􏱺

􏷘+􏷗􏷒select lanes prior to forming a submap loop􏷑
􏴅Lane Selection􏴆
􏷐Mark the lanes prior to the lanes that would create a submap loop􏷏
􏶠Ensures that each selected lane comes before a submap loop is formed along the route􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨
􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    std::set<hub::base::guid> seen;
    hub::base::guid previous;
    􏵲iterate with algorithm window􏵳route,range,[&](size_t i){
        auto id = local_map::internal::submap_identifier(route.lane_sequence[i]);
        
        if (previous != id){
            if (seen.find(id) != seen.end()){
                􏵲insert previous􏵳lane_indexes,i);
                seen.clear();
                seen.insert(previous);
            }
        }
        previous = id;
        seen.insert(id);
    });
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_lanes_prior_to_forming_a_submap_loop(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯select before submap loop􏴰
􏲝We should be able to select the lane before the submap loop occurs􏲞
􏲛Implementation is no longer selecting the lane before the submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1});
    
    //ACT
    auto indexes = select_lanes_prior_to_forming_a_submap_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(3) != indexes.end());
􏴮
􏴯select before submap loop twice􏴰
􏲝We should be able to select the lane before the submap loops occur􏲞
􏲛Implementation is no longer selecting the lane before each submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1,2,2,1,1});
    
    //ACT
    auto indexes = select_lanes_prior_to_forming_a_submap_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(3) != indexes.end());
    EXPECT_TRUE(indexes.find(5) != indexes.end());
    EXPECT_TRUE(indexes.find(7) != indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_lanes_prior_to_forming_a_submap_loop(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_lanes_prior_to_forming_a_submap_loop(r)􏱺





􏷘+􏷗􏷒select first lanes involved in submap loop􏷑
􏴅Lane Selection􏴆
􏷐when we detect submap loops, select the first lane that is part of the submap loop􏷏
􏶠Ensures that each selected lane is the first lane in a submap that is part of a submap loop􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    std::map<hub::base::guid,size_t> seen;
    stdx::optional<hub::base::guid> previous;
    
    
    􏵲iterate with algorithm window􏵳route,range,[&](size_t i){
        auto id = local_map::internal::submap_identifier(route.lane_sequence[i]);
        
        if (!previous || *previous != id){
            auto found = seen.find(id);
            if (found != seen.end()){
                lane_indexes.insert(found->second);
            }
            seen[id] = i;
        }
        previous = id;
    });
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_first_lanes_involved_in_submap_loop(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯select first lane of submap loop􏴰
􏲝We should be able to select the first laneof a submap loop􏲞
􏲛Implementation is no longer selecting the first lane of a submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1});
    
    //ACT
    auto indexes = select_first_lanes_involved_in_submap_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) == indexes.end());
􏴮
􏴯select first lane of each submap loop􏴰
􏲝We should be able to select the lane before the submap loops occur􏲞
􏲛Implementation is no longer selecting the lane before each submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1,2,2,1,1});
    
    //ACT
    auto indexes = select_first_lanes_involved_in_submap_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(4) != indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_first_lanes_involved_in_submap_loop(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_first_lanes_involved_in_submap_loop(r)􏱺

􏷘+􏷗􏷒select all lanes in entered submap loop􏷑
􏴅Lane Selection􏴆
􏷐when we detect submap loops, select the all lanes that are part of the first time we are in the submap􏷏
􏶠Ensures that each selected lane is part of the first set of lanes in the loop conflicting submap􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    auto conflicting_submap_indexes = 􏵲select first lanes involved in submap loop􏵳route,range);
    for (auto const& it: conflicting_submap_indexes){
        auto conflicting_submap = local_map::internal::submap_identifier(route.lane_sequence[it]);
        for (size_t i = it; i < 􏵲algorithm end􏵳route,range); ++i){
            auto next_submap = local_map::internal::submap_identifier(route.lane_sequence[i]);
            if (next_submap == conflicting_submap){
                lane_indexes.insert(i);
            }
            else
            {
                break;
            }
        }
    }
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_all_lanes_in_entered_submap_loop(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯multiple submap loop start􏴰
􏲝Check that all the lanes in the beginning of a submap loop are selected􏲞
􏲛Implementation is no longer selecting the first lanes in the submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,0,0,2,3,4,5,0,0,0});
    
    //ACT
    auto indexes = select_all_lanes_in_entered_submap_loop(r);
    
    //ASSERT
    //zero is the submap loop
    //we check for the first lanes that are a part of that loop
    EXPECT_EQ(indexes.size(),2);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) != indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) == indexes.end());
    EXPECT_TRUE(indexes.find(6) == indexes.end());
    EXPECT_TRUE(indexes.find(7) == indexes.end());
    EXPECT_TRUE(indexes.find(8) == indexes.end());
    EXPECT_TRUE(indexes.find(9) == indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_all_lanes_in_entered_submap_loop(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_all_lanes_in_entered_submap_loop(r)􏱺


􏷘+􏷗􏷒select first lane after loop causing submaps􏷑
􏴅Lane Selection􏴆
􏷐when we detect submap loops, select the first lane along the route that is past the conflicting submap􏷏
􏶠The lanes that are selected are still a part of the overall loop, but we are now outside the submap that we will later revisit􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    auto conflicting_submap_indexes = 􏵲select first lanes involved in submap loop􏵳route,range);
    for (auto const& it: conflicting_submap_indexes){
        auto conflicting_submap = local_map::internal::submap_identifier(route.lane_sequence[it]);
        for (size_t i = it; i < 􏵲algorithm end􏵳route,range); ++i){
            auto next_submap = local_map::internal::submap_identifier(route.lane_sequence[i]);
            if (next_submap != conflicting_submap){
                lane_indexes.insert(i);
                break;
            }
        }
    }
􏶳
􏴯select lanes after loops􏴰
􏲝We should be able to select the lanes immediately after submap loops􏲞
􏲛Implementation is no longer selecting the lane after the submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1,2,2,1,1});
    
    //ACT
    auto indexes = select_first_lane_after_loop_causing_submaps(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) != indexes.end());
    EXPECT_TRUE(indexes.find(5) == indexes.end());
    EXPECT_TRUE(indexes.find(6) != indexes.end());
    EXPECT_TRUE(indexes.find(7) == indexes.end());
    EXPECT_TRUE(indexes.find(8) == indexes.end());
    EXPECT_TRUE(indexes.find(9) == indexes.end());
􏴮
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_first_lane_after_loop_causing_submaps(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_first_lane_after_loop_causing_submaps(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_first_lane_after_loop_causing_submaps(r)􏱺

􏷘+􏷗􏷒select first lane in unique submap after entering loop􏷑
􏴅Lane Selection􏴆
􏷐when we enter a submap inside a submap loop, select the first lane in the next submap􏷏
􏶠A1 B1 A2 will select A2
A1 B1 C1 D1 A2 will select C1􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    auto first_lanes = 􏵲select first lane after loop causing submaps􏵳route,range);
    for (const auto & i: first_lanes){
        auto lane_index = 􏵲first lane of next unique submap􏵳route,i,range);
        if (lane_index){
            lane_indexes.insert(*lane_index);
        }
    }
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_first_lane_in_unique_submap_after_entering_loop(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯aba select second a􏴰
􏲝For this algorithm, we should select A2 in an A1 B1 A2 submap loop􏲞
􏲛Implementation is no longer meeting ABA example􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({0,0,0,0,1,0,0,0,0});
    
    //ACT
    auto indexes = select_first_lane_in_unique_submap_after_entering_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) != indexes.end());
    EXPECT_TRUE(indexes.find(6) == indexes.end());
    EXPECT_TRUE(indexes.find(7) == indexes.end());
    EXPECT_TRUE(indexes.find(8) == indexes.end());
􏴮
􏴯abcda select c􏴰
􏲝For this algorithm, we should select A2 in an A1 B1 A2 submap loop􏲞
􏲛Implementation is no longer meeting ABA example􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({0,1,2,3,0});
    
    //ACT
    auto indexes = select_first_lane_in_unique_submap_after_entering_loop(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_first_lane_in_unique_submap_after_entering_loop(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_first_lane_in_unique_submap_after_entering_loop(r)􏱺

􏷘-􏷗􏷒first lane of next unique submap􏷑
􏴅Detail􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to search for further lanes on􏶿
􏶜􏶝􏷆size􏷅􏷄lane index􏷃􏷀the lane index to start looking forward from􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m?􏶛􏶾size􏶽􏶼next lane in unique submap􏶻􏶺the first lane of the next unique submap􏶹
􏶴
    auto current_submap = local_map::internal::submap_identifier(route.lane_sequence[lane_index]);
    for (size_t i = lane_index; i < 􏵲algorithm end􏵳route,range); ++i){
        auto next_submap = local_map::internal::submap_identifier(route.lane_sequence[i]);
        if (current_submap != next_submap){
            next_lane_in_unique_submap = i;
            break;
        }
    }
􏶳

􏷘+􏷗􏷒select second lane after loop causing submaps􏷑
􏴅Lane Selection􏴆
􏷐when we detect submap loops, select the second lane along the route that is past the conflicting submap􏷏
􏶠The lanes that are selected are still a part of the overall loop, but we are now either outside the submap that we will later revisit, or back on the revisitation of the submap􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    auto conflicting_submap_indexes = 􏵲select first lanes involved in submap loop􏵳route,range);
    for (auto const& it: conflicting_submap_indexes){
        auto conflicting_submap = local_map::internal::submap_identifier(route.lane_sequence[it]);
        for (size_t i = it; i < 􏵲algorithm end􏵳route,range); ++i){
            auto next_submap = local_map::internal::submap_identifier(route.lane_sequence[i]);
            if (next_submap != conflicting_submap){
                􏵲insert next􏵳lane_indexes,route,i);
                break;
            }
        }
    }
􏶳
􏴯select lanes after loops􏴰
􏲝We should be able to select the lanes immediately after submap loops􏲞
􏲛Implementation is no longer selecting the lane after the submap loop􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,1,1,2,2,1,1});
    
    //ACT
    auto indexes = select_second_lane_after_loop_causing_submaps(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) != indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) != indexes.end());
    EXPECT_TRUE(indexes.find(6) == indexes.end());
    EXPECT_TRUE(indexes.find(7) != indexes.end());
    EXPECT_TRUE(indexes.find(8) == indexes.end());
    EXPECT_TRUE(indexes.find(9) == indexes.end());
􏴮
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_second_lane_after_loop_causing_submaps(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_second_lane_after_loop_causing_submaps(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_second_lane_after_loop_causing_submaps(r)􏱺

􏷘+􏷗􏷒select lanes that transition to new submaps􏷑
􏴅Lane Selection􏴆
􏷐select every lane that transitions to a different submap􏷏
􏶠Ensures that each selected lane exists in a different submap that the previous selected lane􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    hub::base::guid previous;
    􏵲iterate with algorithm window􏵳route,range,[&](size_t i){
        auto id = local_map::internal::submap_identifier(route.lane_sequence[i]);
        
        if (previous != id){
            lane_indexes.insert(i);
        }
        previous = id;
    });
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_lanes_that_transition_to_new_submaps(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯select lanes into new submaps􏴰
􏲝We should be able to select each lane in a submap transition􏲞
􏲛Implementation is no longer selecting each new lane in a submap transition􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,2,1});
    
    //ACT
    auto indexes = select_lanes_that_transition_to_new_submaps(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),3);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) != indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_lanes_that_transition_to_new_submaps(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_lanes_that_transition_to_new_submaps(r)􏱺


􏷘+􏷗􏷒select first lane􏷑
􏴅Lane Selection􏴆
􏷐Marks the first lane of the route􏷏
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    if (􏵲has lanes􏵳route)){
        auto index = 􏵲algorithm start􏵳route,range);
        if (index < 􏵲number of lanes􏵳route)){
            lane_indexes.insert(index);
        }
    }
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_first_lane(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯last􏴰
􏲝Marks the first lane􏲞
􏲛Implementation is no longer selecting the first lane􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,1,2});
    
    //ACT
    auto indexes = select_first_lane(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_first_lane(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_first_lane(r)􏱺

􏷘+􏷗􏷒select last lane􏷑
􏴅Lane Selection􏴆
􏷐Marks the last lane of the route􏷏
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    if (􏵲has lanes􏵳route)){
        auto index = 􏵲algorithm end􏵳route,range);
        if (index > 0){
            lane_indexes.insert(index -1);
        }
    }
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_last_lane(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯last􏴰
􏲝Marks the last lane􏲞
􏲛Implementation is no longer selecting the last lane􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,2,2,2});
    
    //ACT
    auto indexes = select_last_lane(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(3) != indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_last_lane(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_last_lane(r)􏱺

􏷘+􏷗􏷒select all lanes􏷑
􏴅Lane Selection􏴆
􏷐Marks all of the lanes in the route􏷏
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    􏵲iterate with algorithm window􏵳route,range,[&](size_t i){
        lane_indexes.insert(i);
    });
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto indexes = select_all_lanes(r);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯all􏴰
􏲝All of the lanes should be selected􏲞
􏲛Implementation is no longer selecting all of the lanes􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,1,2,2,3,3});
    
    //ACT
    auto indexes = select_all_lanes(r);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),6);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) != indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(3) != indexes.end());
    EXPECT_TRUE(indexes.find(4) != indexes.end());
    EXPECT_TRUE(indexes.find(5) != indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_last_lane(r);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_all_lanes(r)􏱺

􏷘+􏷗􏷒select specific lane index􏷑
􏴅Lane Selection􏴆
􏷐Marks the specific lane index given􏷏
􏶠If the lane index is greater than the length of the route, then an empty set is returned
The set returned will never have more than 1 element􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆size􏷅􏷄lane index􏷃􏷀the index of the lane to select􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    auto adjusted_lane_index = 􏵲algorithm start􏵳route,range) + lane_index;
    if (adjusted_lane_index < 􏵲algorithm end􏵳route,range)){
        lane_indexes.insert(adjusted_lane_index);
    }
􏶳
􏴯select first lane􏴰
􏲝We should be able to select the first lane of a route􏲞
􏲛Implementation is no longer allowing the first lane to be selected􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,2,3,4,5,6});
    
    //ACT
    auto indexes = select_specific_lane_index(r,0);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) != indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) == indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) == indexes.end());
􏴮
􏴯select specific lane􏴰
􏲝We should be able to select a specific lane of a route􏲞
􏲛Implementation is no longer allowing a specific lane to be selected􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,2,3,4,5,6});
    
    //ACT
    auto indexes = select_specific_lane_index(r,2);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),1);
    EXPECT_TRUE(indexes.find(0) == indexes.end());
    EXPECT_TRUE(indexes.find(1) == indexes.end());
    EXPECT_TRUE(indexes.find(2) != indexes.end());
    EXPECT_TRUE(indexes.find(3) == indexes.end());
    EXPECT_TRUE(indexes.find(4) == indexes.end());
    EXPECT_TRUE(indexes.find(5) == indexes.end());
􏴮
􏴯out of bounds lane selects nothing􏴰
􏲝WIf we try to select a lane index that doesn't exist, we get no indexes back􏲞
􏲛Implementation is no longer allowing invalid lane indexes for silently selecting nothing􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,2,3,4,5,6});
    
    //ACT
    auto indexes = select_specific_lane_index(r,6);
    
    //ASSERT
    EXPECT_EQ(indexes.size(),0);
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_specific_lane_index(r,0);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_specific_lane_index(r,0)􏱺



􏷘+􏷗􏷒select lanes for local map sla requirement􏷑
􏴅Lane Selection􏴆
􏷐selects lanes based on the local map's regeneration SLA requirements􏷏
􏶠Ensures that the proper lanes are selected to guarantee by the local map's SLA requirements during regeneration􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to select lanes􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to minimally reach􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the window over the route to perform the algorithm on. default is the entire route􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾unordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    􏶲perform selecting policies􏶱
    􏵲merge􏵳lane_indexes,􏵲select lanes that exceed accumulated distance􏵳route,distance_m,range));
    􏵲merge􏵳lane_indexes,􏵲select first lane in unique submap after entering loop􏵳route));
    􏵲merge􏵳lane_indexes,􏵲select first lane􏵳route,range));
    
    􏶲CONSIDER(thickey): we may want to do additional filtering􏶱
    􏶲probably convert this to a distance aware loop cutting with an offset from the explicitly selected first lane􏶱
    􏶲currently using a strategy that has little to no effect on PBM􏶱
􏶳
􏴯empty􏴰
􏲝We should be able to select empty routes without issue􏲞
􏲛Implementation is no longer handling empty routes correctly􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto any_valid_distance_m = 1.0;
    auto indexes = select_lanes_for_local_map_sla_requirement(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.empty());
􏴮
􏴯a1 b1 a1 should b1􏴰
􏲝In the case of an ABA submap loop, we should regenerate in the 2nd A submap􏲞
􏲛Algorithm is no longer selecting the 2nd A lane in an ABA situation􏲜
􏴭
    //ARRANGE
   auto r = create_route_from_submap_ids({1,2,1});
    
    //ACT
    // We set a very large distance, because we aren't interested in any lanes being selected by the distance requirement.
    // If the distance is larger than all of the lane distances accumulated, the distance provided will not cause any additional lanes to be selected
    // This allows us to test the SLA submap loop selecting logic without influence from the distance
    auto any_valid_distance_m = 10000.0;
    auto indexes = select_lanes_for_local_map_sla_requirement(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.find(2) != indexes.end());
􏴮

􏴯buffer a1 b1 a1 should b1􏴰
􏲝In the case of an ABA submap loop, we should regenerate in the 2nd A submap􏲞
􏲛Algorithm is no longer selecting the 2nd A lane in an ABA situation􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({0,0,0,1,2,1});
    
    //ACT
    // We set a very large distance, because we aren't interested in any lanes being selected by the distance requirement.
    // If the distance is larger than all of the lane distances accumulated, the distance provided will not cause any additional lanes to be selected
    // This allows us to test the SLA submap loop selecting logic without influence from the distance
    auto any_valid_distance_m = 10000.0;
    auto indexes = select_lanes_for_local_map_sla_requirement(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.find(5) != indexes.end());
􏴮
􏴯a1 b1 a1 buffer should b1􏴰
􏲝In the case of an ABA submap loop, we should regenerate in the 2nd A submap􏲞
􏲛Algorithm is no longer selecting the 2nd A lane in an ABA situation􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,1,0,0,0});
    
    //ACT
    // We set a very large distance, because we aren't interested in any lanes being selected by the distance requirement.
    // If the distance is larger than all of the lane distances accumulated, the distance provided will not cause any additional lanes to be selected
    // This allows us to test the SLA submap loop selecting logic without influence from the distance
    auto any_valid_distance_m = 10000.0;
    auto indexes = select_lanes_for_local_map_sla_requirement(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.find(2) != indexes.end());
􏴮
􏴯buffer a1 b1 a1 buffer should b1􏴰
􏲝In the case of an ABA submap loop, we should regenerate in the 2nd A submap􏲞
􏲛Algorithm is no longer selecting the 2nd A lane in an ABA situation􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({0,0,0,1,2,1,0,0,0});
    
    //ACT
    // We set a very large distance, because we aren't interested in any lanes being selected by the distance requirement.
    // If the distance is larger than all of the lane distances accumulated, the distance provided will not cause any additional lanes to be selected
    // This allows us to test the SLA submap loop selecting logic without influence from the distance
    auto any_valid_distance_m = 10000.0;
    auto indexes = select_lanes_for_local_map_sla_requirement(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.find(5) != indexes.end());
􏴮
􏴯buffer a1 b1 b2 b3 c1 c2 a1 buffer should c1􏴰
􏲝In the case of an ABBBCCA submap loop, we should regenerate on the first C􏲞
􏲛Algorithm is no longer selecting the correct lane􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({0,0,0,1,1,1,1,2,2,0,0,0});
    
    //ACT
    // We set a very large distance, because we aren't interested in any lanes being selected by the distance requirement.
    // If the distance is larger than all of the lane distances accumulated, the distance provided will not cause any additional lanes to be selected
    // This allows us to test the SLA submap loop selecting logic without influence from the distance
    auto any_valid_distance_m = 10000.0;
    auto indexes = select_lanes_for_local_map_sla_requirement(r,any_valid_distance_m);
    
    //ASSERT
    EXPECT_TRUE(indexes.find(7) != indexes.end());
􏴮
􏴯interesting route stress test􏴰
􏲝Run algorithm over different routes; ensure no crashes􏲞
􏲛The algorithm crashed over an interesting route and it should not have􏲜
􏴭
    //ARRANGE
    random_route_creation_input settings;
    auto distance_m = 0;
    auto routes = create_interesting_test_routes(settings);
    
    //ACT
    for (const auto & r: routes){
        auto indexes = select_lanes_for_local_map_sla_requirement(r,distance_m);
        EXPECT_TRUE(true);
    }
􏴮
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    const auto r = create_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::select_lanes_for_local_map_sla_requirement(r,100)􏱺

􏷘+􏷗􏷒create event route􏷑
􏴅Annotated Route􏴆
􏷐Take a translated route, and convert it into an event annotated route􏷏
􏶠The event annotated route will not have any regeneration events selected by default􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to create an event route from􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏶺a route with regeneration information attached􏶹
􏶴

    // optimization
    event_route.event_lane_sequence.reserve(number_of_lanes(route));
    
    event_route.route_plan_id = route.route_plan_id;
    event_route.evaluation_range.current = route.route_progress_index;
    for (size_t i = 0; i < 􏵲number of lanes􏵳route); ++i){
        lane event;
        event.info.map_ref = route.lane_sequence[i];
        event.info.annotation = route.annotation_sequence[i];
        event_route.event_lane_sequence.emplace_back(event);
    }
􏶳
􏴯empty conversion􏴰
􏲝We turn an empty route into an event route􏲞
􏲛Implementation is can't convert empty routes to event routes􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_TRUE(event_route.event_lane_sequence.empty());
􏴮
􏴯preserve lane count􏴰
􏲝Converting a route to an event route preserves lane count􏲞
􏲛Conversion is not preserving lane count􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,0,1});
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_EQ(event_route.event_lane_sequence.size(),3);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    std::vector<double>                       distances(s.range(0), 10.0f);
    auto                                      route = local_map::statik::create_route_from_lane_distances(distances);
􏱼
􏱹local_map::statik::create_event_route(route)􏱺


􏷘+􏷗􏷒create translated route􏷑
􏴅Annotated Route􏴆
􏷐Take an event route, and convert it into a translated route􏷏
􏶠The translated route will lose any event related information􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏷄event route􏷃􏷀the route to create a translated route from􏶿
􏶚m􏶛􏶾route􏶽􏶼route􏶻􏶺the original translated route with regeneration information stripped􏶹
􏶴
    route.route_plan_id = event_route.route_plan_id;
    route.route_progress_index = event_route.evaluation_range.current.value_or(0);
    
    for (size_t i = 0; i < 􏵲number of lanes􏵳event_route); ++i){
    
        route.lane_sequence.emplace_back(event_route.event_lane_sequence[i].info.map_ref);
        route.annotation_sequence.emplace_back(event_route.event_lane_sequence[i].info.annotation);
    }
􏶳
􏴯sub id event route back to translated􏴰
􏲝check that we can create an event route from submap ids and convert it back to a translated route􏲞
􏲛the translated route no longer has the same information as the event route once converted􏲜
􏴭
    //ARRANGE
    std::vector<int> submap_ids{2,4,6,8,10};
    auto event_route = create_event_route_from_submap_ids(submap_ids);
    
    //ACT
    auto translated_route = create_translated_route(event_route);
    
    //ASSERT
    EXPECT_EQ(translated_route.lane_sequence[0].map_index.to_int64(),2);
    EXPECT_EQ(translated_route.lane_sequence[1].map_index.to_int64(),4);
    EXPECT_EQ(translated_route.lane_sequence[2].map_index.to_int64(),6);
    EXPECT_EQ(translated_route.lane_sequence[3].map_index.to_int64(),8);
    EXPECT_EQ(translated_route.lane_sequence[4].map_index.to_int64(),10);
􏴮
􏴯distance event route back to translated􏴰
􏲝check that we can create an event route from distances and convert it back to a translated route􏲞
􏲛the translated route no longer has the same information as the event route once converted􏲜
􏴭
    //ARRANGE
    std::vector<double> distances{2.5,4.5,6.5,8.5,10.5};
    auto event_route = create_event_route_from_lane_distances(distances);
    
    //ACT
    auto translated_route = create_translated_route(event_route);
    
    //ASSERT
    EXPECT_EQ(translated_route.annotation_sequence[0].distance,2.5);
    EXPECT_EQ(translated_route.annotation_sequence[1].distance,4.5);
    EXPECT_EQ(translated_route.annotation_sequence[2].distance,6.5);
    EXPECT_EQ(translated_route.annotation_sequence[3].distance,8.5);
    EXPECT_EQ(translated_route.annotation_sequence[4].distance,10.5);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double>                       distances(s.range(0), 10.0f);
    const auto                                      route = local_map::statik::create_route_from_lane_distances(distances);
    const auto event_route = local_map::statik::create_event_route(route);
􏱼
􏱹local_map::statik::create_translated_route(event_route)􏱺

􏷘+􏷗􏷒create event route􏷑
􏴅Annotated Route􏴆
􏷐Take the route creation input, and convert it into an event annotated route􏷏
􏶠The event annotated route may have regeneration events selected based on the route creation's annotation strategy􏶡
􏶜􏶝􏷆route_creation_input􏷅􏲥local_map/libs/regeneration/local_map_regeneration_preset_routes􏲦􏷄input􏷃􏷀the input to create an event route from􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏲅create_event_route(create_route_from_test_input(input))􏲆􏶺a route with regeneration information attached􏶹
􏶴􏶳
􏴯preserve lane count 2􏴰
􏲝Converting a route creation input to an event route preserves the lane count􏲞
􏲛Conversion is not preserving lane count􏲜
􏴭
    //ARRANGE
    route_creation_input input;
    lane_creation_input lane;
    lane.submap_id = 1;
    lane.distance_m = 100;
    input.lane_input_sequence.emplace_back(lane);
    lane.submap_id = 2;
    lane.distance_m = 100;
    input.lane_input_sequence.emplace_back(lane);
    lane.submap_id = 3;
    lane.distance_m = 100;
    input.lane_input_sequence.emplace_back(lane);
    
    //ACT
    auto event_route = create_event_route(input);
    
    //ASSERT
    EXPECT_EQ(event_route.event_lane_sequence.size(),3);
􏴮
􏱿regular growth􏲀􏱽with_input􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    route_creation_input input;
    for (size_t i = 0; i < s.range(0); ++i){
        lane_creation_input lane;
        lane.submap_id = i;
        lane.distance_m = 100;
        input.lane_input_sequence.emplace_back(lane);
    }
􏱼
􏱹local_map::statik::create_event_route(input)􏱺

􏷘+􏷗􏷒create random event route􏷑
􏴅Annotated Route􏴆
􏷐Take the random route creation input, and convert it into an event annotated route􏷏
􏶠The event annotated route may have regeneration events selected based on the route creation's annotation strategy􏶡
􏶜􏶝􏷆random_route_creation_input􏷅􏲥local_map/libs/regeneration/local_map_regeneration_preset_routes􏲦􏷄input􏷃􏷀the input to create a random event route from􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏲅create_event_route(create_random_route(input))􏲆􏶺a random route with random regeneration information attached􏶹
􏶴􏶳
􏴯create deterministically􏴰
􏲝make sure that creating a random event route does not crash􏲞
􏲛creating a random route with default random settings should always pass􏲜
􏴭
    //ARRANGE
    random_route_creation_input input;
    
    //ACT
    auto event_route = create_random_event_route(input);
    
    //ASSERT
    (void)event_route;
􏴮
􏴯prove its deterministic􏴰
􏲝show that we are testing deterministic random􏲞
􏲛we are unable to create an event or the event creation is no longer deterministic􏲜
􏴭
    //ARRANGE
    random_route_creation_input input;
    input.low_lane_count = 5;
    input.high_lane_count = 5;
    
    //ACT
    auto event_route = create_random_event_route(input);
    
    //ASSERT
    //the values are the same random sequence every program invocation
    EXPECT_EQ(static_cast<int>(event_route.event_lane_sequence[0].info.annotation.distance),33);
    EXPECT_EQ(static_cast<int>(event_route.event_lane_sequence[1].info.annotation.distance),21);
    EXPECT_EQ(static_cast<int>(event_route.event_lane_sequence[2].info.annotation.distance),24);
    EXPECT_EQ(static_cast<int>(event_route.event_lane_sequence[3].info.annotation.distance),17);
    EXPECT_EQ(static_cast<int>(event_route.event_lane_sequence[4].info.annotation.distance),2);
    
    EXPECT_EQ(event_route.event_lane_sequence[0].info.map_ref.map_index.to_int64(),6);
    EXPECT_EQ(event_route.event_lane_sequence[1].info.map_ref.map_index.to_int64(),6);
    EXPECT_EQ(event_route.event_lane_sequence[2].info.map_ref.map_index.to_int64(),9);
    EXPECT_EQ(event_route.event_lane_sequence[3].info.map_ref.map_index.to_int64(),7);
    EXPECT_EQ(event_route.event_lane_sequence[4].info.map_ref.map_index.to_int64(),3);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    random_route_creation_input input;
    
    //set exact route length
    input.low_lane_count = s.range(0);
    input.high_lane_count = s.range(0);
􏱼
􏱹local_map::statik::create_random_event_route(input)􏱺

􏷘+􏷗􏷒create event route from lane distances􏷑
􏴅Annotated Route􏴆
􏷐Creates an event route based on the provided lane distances􏷏
􏶠The only reliable information defined will be the route's annotated lane distances􏶡
􏶜􏶝􏷆seq􏷅􏳣double􏳤􏷄lane distances􏷃􏵘meters􏵙􏷀the lane distances used to create a route􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏲅create_event_route(create_route_from_lane_distances(lane_distances_m))􏲆􏶺an event route􏶹
􏶴􏶳
􏴯create􏴰
􏲝We should be able to create an event routed with the appropriate distances􏲞
􏲛The distances are no longer being set correctly􏲜
􏴭
    //ARRANGE
    std::vector<double> distances_m{20,40,60,80};
    
    //ACT
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    //ASSERT
    for (size_t i = 0; i < event_route.event_lane_sequence.size(); ++i){
        EXPECT_EQ(event_route.event_lane_sequence[i].info.annotation.distance,distances_m[i]);
    }
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    std::vector<double> distances_m(s.range(0),100);
􏱼
􏱹local_map::statik::create_event_route_from_lane_distances(distances_m)􏱺

􏷘+􏷗􏷒create event route from submap ids􏷑
􏴅Annotated Route􏴆
􏷐Creates an event route based on the provided submap identifier􏷏
􏶠The only reliable information defined will be the route's submap identifier
We use ints for testing convenience
They are converted to guids􏶡
􏶜􏶝􏷆seq􏷅􏳣int􏳤􏷄submap ids􏷃􏷀the submap ids used to create a route􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏲅create_event_route(create_route_from_submap_ids(submap_ids))􏲆􏶺an event route􏶹
􏶴􏶳
􏴯create􏴰
􏲝We should be able to create an event routed with the appropriate submap ids􏲞
􏲛The submap ids are no longer being set correctly􏲜
􏴭
    //ARRANGE
    std::vector<int> submap_ids{2,4,6,8};
    
    //ACT
    auto event_route = create_event_route_from_submap_ids(submap_ids);
    
    //ASSERT
    for (size_t i = 0; i < event_route.event_lane_sequence.size(); ++i){
        EXPECT_EQ(event_route.event_lane_sequence[i].info.map_ref.map_index.to_int64(),submap_ids[i]);
    }
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    std::vector<int> submap_ids;
    submap_ids.reserve(s.range(0));
    for (size_t i = 0; i < s.range(0); ++i){
        submap_ids.emplace_back(i);
    }
􏱼
􏱹local_map::statik::create_event_route_from_submap_ids(submap_ids)􏱺

􏷘+􏷗􏷒create event route from test input􏷑
􏴅Annotated Route􏴆
􏷐Creates an event route based on the provided route creation input􏷏
􏶠Creates a version of an event route based on the creation input provided􏶡
􏶜􏶝􏷆route_creation_input􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄creation input􏷃􏷀creation input used to create the translated route􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏲅create_event_route(create_route_from_test_input(creation_input))􏲆􏶺an event route􏶹
􏶴􏶳
􏴯create with distances􏴰
􏲝We should be able to create an event route with creation input􏲞
􏲛The distances are no longer being set correctly􏲜
􏴭
    //ARRANGE
    std::vector<double> distances_m{20,40,60,80};
    route_creation_input input;
    lane_creation_input lane;
    
    for (size_t i = 0; i < distances_m.size(); ++i){
        lane.distance_m = distances_m[i];
        input.lane_input_sequence.emplace_back(lane);
    }
    
    //ACT
    auto event_route = create_event_route_from_test_input(input);
    
    //ASSERT
    for (size_t i = 0; i < event_route.event_lane_sequence.size(); ++i){
        EXPECT_EQ(event_route.event_lane_sequence[i].info.annotation.distance,distances_m[i]);
    }
􏴮
􏴯create with ids􏴰
􏲝We should be able to create an event route with creation input􏲞
􏲛The submap ids are no longer being set correctly􏲜
􏴭
    //ARRANGE
    std::vector<int> submap_ids{2,4,6,8};
    route_creation_input input;
    lane_creation_input lane;
    
    for (size_t i = 0; i < submap_ids.size(); ++i){
        lane.submap_id = submap_ids[i];
        input.lane_input_sequence.emplace_back(lane);
    }
    
    //ACT
    auto event_route = create_event_route_from_test_input(input);
    
    //ASSERT
    for (size_t i = 0; i < event_route.event_lane_sequence.size(); ++i){
        EXPECT_EQ(event_route.event_lane_sequence[i].info.map_ref.map_index.to_int64(),submap_ids[i]);
    }
􏴮

􏴯create with distances and ids􏴰
􏲝We should be able to create an event route with creation input􏲞
􏲛The submap ids and the distances are no longer being set correctly􏲜
􏴭
    //ARRANGE
    std::vector<double> distances_m{20,40,60,80};
    std::vector<int> submap_ids{2,4,6,8};
    route_creation_input input;
    lane_creation_input lane;
    
    for (size_t i = 0; i < distances_m.size(); ++i){
        lane.submap_id = submap_ids[i];
        lane.distance_m = distances_m[i];
        input.lane_input_sequence.emplace_back(lane);
    }
    
    //ACT
    auto event_route = create_event_route_from_test_input(input);
    
    //ASSERT
    for (size_t i = 0; i < event_route.event_lane_sequence.size(); ++i){
        EXPECT_EQ(event_route.event_lane_sequence[i].info.map_ref.map_index.to_int64(),submap_ids[i]);
    }
    for (size_t i = 0; i < event_route.event_lane_sequence.size(); ++i){
        EXPECT_EQ(event_route.event_lane_sequence[i].info.annotation.distance,distances_m[i]);
    }
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    std::vector<double> distances_m(s.range(0),100);
    
    route_creation_input input;
    lane_creation_input lane;
    
    for (size_t i = 0; i < distances_m.size(); ++i){
        lane.distance_m = distances_m[i];
        input.lane_input_sequence.emplace_back(lane);
    }
􏱼
􏱹local_map::statik::create_event_route_from_test_input(input)􏱺





􏷘+􏷗􏷒create slmt event route􏷑
􏴅Annotated Route􏴆
􏷐Create an event route specific to the SLMT use case􏷏
􏶠We assume the information provided will be gathered cycle over cycle
This means we we will create an entirely new event route every cycle based on other information known in the SLMT􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to create an event route from􏶿
􏶜􏶝􏷆slmt_route_information􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route info􏷃􏷀information about the AV's current route provided by the SLMT􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀a distance offset along the lane to place the maker when using the SLMT selecting algorithm􏶿
􏶚m􏶛􏶾event_annotated_route􏶽􏶼event route􏶻􏲅create_event_route(route)􏲆􏶺a route with SLMT event information attached􏶹
􏶴

    // the event window is preserved based on indexes in the seed
    // we apply this window to the annotated route
    􏵲set event window from slmt state􏵳event_route, route_info);
    
    // Mark lanes for regeneration.
    // Using the chosen lane selecting algorithm, select lanes to determine when we should regenerate.
    // Start the algorithm at the "current index" of the route.
    // This is our true route beginning along a merged route.
    algorithm_window window;
    window.start = route_info.merge_point_index;
    auto lane_selections = 􏵲select lanes for local map sla requirement􏵳route, distance_m,window);
    􏵲set regeneration events􏵳event_route, lane_selections, "SLA");
􏶳
􏴯simulate slmt cycle changes on route􏴰
􏲝Ensure that we are progressing through the route when we create an annotated route cycle over cycle􏲞
􏲛We are no longer advancing forward through the annotated route cycle over cycle􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6});
    route_info.route_changed = true;
    route_info.previous_lane_index = 0;
    route_info.current_lane_index = 0;
    int distance_m = 100;
    
    //ACT
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(?,0]");
    EXPECT_EQ(event_route.event_lane_sequence.size(),6);
    
    //ARRANGE
    route_info.route_changed = false;
    
    //ACT
    event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(0,0]");
    EXPECT_EQ(event_route.event_lane_sequence.size(),6);
    
    //ARRANGE
    route_info.previous_lane_index = 1;
    route_info.current_lane_index = 2;
    
    //ACT
    event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(1,2]");
    EXPECT_EQ(event_route.event_lane_sequence.size(),6);
    
    //ARRANGE
    route_info.previous_lane_index = 2;
    route_info.current_lane_index = 3;
    
    //ACT
    event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(2,3]");
    EXPECT_EQ(event_route.event_lane_sequence.size(),6);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    std::vector<double>                       distances(s.range(0), 10.0f);
    auto                                      route = local_map::statik::create_route_from_lane_distances(distances);
    local_map::statik::slmt_route_information route_info;
􏱼
􏱹local_map::statik::create_slmt_event_route(route, route_info, 20.0)􏱺



􏷘-􏷗􏷒set event window from slmt state􏷑
􏴅Detail􏴆
􏷐Configure the SLMT annotated route according to the task's seed􏷏
􏶠This will properly configure the event window where will process for events, based on the information in the seed􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏷄event route􏷃􏷀the input to create an event route from􏶿
􏶜􏶝􏷆slmt_route_information􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route info􏷃􏷀information about the AV's current route provided by the SLMT􏶿
􏶴
    // if the route changed, we'll keep the default start of the window
    // this will ensure we process from the beginning of the route all the way to the current index
    if (!route_info.route_changed)
    {
        􏵲set previous index on route􏵳event_route, route_info.previous_lane_index);
    }
    􏵲set current index on route􏵳event_route, route_info.current_lane_index);
􏶳

􏷘+􏷗􏷒set regeneration events􏷑
􏴅Annotated Route􏴆
􏷐Decide where along the event annotated route where to place regeneration events􏷏
􏶠Applies event actions to take on the lane based on the lane indexes given􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to set events􏶿
􏶜􏶝􏷆unordered_indexes􏷅􏷄lane indexes􏷃􏷀the lane indexes to apply regeneration events to􏶿
􏶜􏶝􏷆ascii_string􏷅􏷄reason􏷃􏷀the reason you are regenerating on these lanes􏶿
􏶴
    for (const auto & lane_index: lane_indexes){
        event e;
        e.action = event_action_regenerate;
        e.reason = reason;
        route.event_lane_sequence[lane_index].event_sequence.emplace_back(e);
    }
􏶳
􏴯select some lanes􏴰
􏲝Check that we can select lanes and see that they are selected􏲞
􏲛We are no longer able to select lanes (or observe them being selected)􏲜
􏴭
    //ARRANGE
    auto r = create_event_route(create_route_from_submap_ids({1,2,3,4,5}));
    std::set<size_t> selects{2,3};
    
    //ACT
    set_regeneration_events(r,selects,"test");
    
    //ASSERT
    EXPECT_EQ(total_event_markings(r),2);
􏴮
􏱿regular growth􏲀􏱽no_selects􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    const std::set<size_t> selects;
􏱼
􏱹local_map::statik::set_regeneration_events(event_route,selects,"test")􏱺
􏱿regular growth􏲀􏱽all_selects􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    std::set<size_t> selects;
    for (size_t i = 0; i < s.range(0); ++i){
        selects.insert(i);
    }
􏱼
􏱹local_map::statik::set_regeneration_events(event_route,selects,"test")􏱺

􏷘+􏷗􏷒set regeneration events􏷑
􏴅Annotated Route􏴆
􏷐Decide where along the event annotated route where to place regeneration events􏷏
􏶠Applies event actions to take on the lane based on the lane indexes given􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to set events􏶿
􏶜􏶝􏷆unordered_indexes􏷅􏷄lane indexes􏷃􏷀the lane indexes to apply regeneration events to􏶿
􏶜􏶝􏷆ascii_string􏷅􏷄reason􏷃􏷀the reason you are regenerating on these lanes􏶿
􏶜􏶝􏷆i􏷅􏷄placement􏷃􏵘percentage􏵙􏷀where along the lane to place the maker􏶿
􏶴
    for (const auto & lane_index: lane_indexes){
        event e;
        e.action = event_action_regenerate;
        e.reason = reason;
        e.distance_m = (route.event_lane_sequence[lane_index].info.annotation.distance / 100) * placement_pct;
        route.event_lane_sequence[lane_index].event_sequence.emplace_back(e);
    }
􏶳
􏴯select some lanes 2􏴰
􏲝Check that we can select lanes and see that they are selected􏲞
􏲛We are no longer able to select lanes (or observe them being selected)􏲜
􏴭
    //ARRANGE
    auto r = create_event_route(create_route_from_submap_ids({1,2,3,4,5}));
    std::set<size_t> selects{2,3};
    int placement_pct = 33;
    
    //ACT
    set_regeneration_events(r,selects,"test",placement_pct);
    
    //ASSERT
    EXPECT_EQ(total_event_markings(r),2);
􏴮
􏱿regular growth􏲀􏱽no_selects_with_pct􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    const std::set<size_t> selects;
􏱼
􏱹local_map::statik::set_regeneration_events(event_route,selects,"test",50)􏱺
􏱿regular growth􏲀􏱽all_selects_with_pct􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    std::set<size_t> selects;
    for (size_t i = 0; i < s.range(0); ++i){
        selects.insert(i);
    }
􏱼
􏱹local_map::statik::set_regeneration_events(event_route,selects,"test",50)􏱺

􏷘+􏷗􏷒set regeneration events􏷑
􏴅Annotated Route􏴆
􏷐Decide where along the event annotated route where to place regeneration events􏷏
􏶠Applies event actions to take on the lane based on the lane indexes given
If the distance is longer than the lane, the event will be placed at the end of the lane􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to set events􏶿
􏶜􏶝􏷆unordered_indexes􏷅􏷄lane indexes􏷃􏷀the lane indexes to apply regeneration events to􏶿
􏶜􏶝􏷆ascii_string􏷅􏷄reason􏷃􏷀the reason you are regenerating on these lanes􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀a distance offset along the lane to place the maker􏶿
􏶴
    for (const auto & lane_index: lane_indexes){
        event e;
        e.action = event_action_regenerate;
        e.reason = reason;
        
        if (distance_m > route.event_lane_sequence[lane_index].info.annotation.distance){
            e.distance_m = route.event_lane_sequence[lane_index].info.annotation.distance;
        }
        else{
            e.distance_m = distance_m;
        }
        route.event_lane_sequence[lane_index].event_sequence.emplace_back(e);
    }
􏶳
􏴯select some lanes 3􏴰
􏲝Check that we can select lanes and see that they are selected􏲞
􏲛We are no longer able to select lanes (or observe them being selected)􏲜
􏴭
    //ARRANGE
    auto r = create_event_route(create_route_from_submap_ids({1,2,3,4,5}));
    std::set<size_t> selects{2,3};
    double distance_m = 0.0;
    
    //ACT
    set_regeneration_events(r,selects,"test",distance_m);
    
    //ASSERT
    EXPECT_EQ(total_event_markings(r),2);
􏴮
􏴯select lane distance offset too large still accepted􏴰
􏲝Check that we can select lanes with a distance offset longer than the lane (it should be capped to the end of the lane)􏲞
􏲛We are no longer able to select lanes with a distance longer than the lane􏲜
􏴭
    //ARRANGE
    auto r = create_event_route_from_lane_distances({20,20,20,20,20,20});
    std::set<size_t> selects{2,3};
    double distance_m = 10000; //intentionally large to test that the marking is still made
    
    //ACT
    set_regeneration_events(r,selects,"test",distance_m);
    
    //ASSERT
    EXPECT_EQ(total_event_markings(r),2);
􏴮

􏱿regular growth􏲀􏱽no_selects_with_distance􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    const std::set<size_t> selects;
􏱼
􏱹local_map::statik::set_regeneration_events(event_route,selects,"test",10)􏱺
􏱿regular growth􏲀􏱽all_selects_with_distance􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    std::set<size_t> selects;
    for (size_t i = 0; i < s.range(0); ++i){
        selects.insert(i);
    }
􏱼
􏱹local_map::statik::set_regeneration_events(event_route,selects,"test",10)􏱺

􏷘+􏷗􏷒set regeneration events􏷑
􏴅Annotated Route􏴆
􏷐Creates a region of events along the route􏷏
􏶠Agnostic to the individual lanes along the route
Can span multiple lanes􏶡
􏵪start_distance_m <= end_distance_m􏵫
􏵨start_distance_m <= end_distance_m􏵩
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to set events􏶿
􏶜􏶝􏷆ascii_string􏷅􏷄reason􏷃􏷀the reason you are regenerating in this region􏶿
􏶜􏶝􏷆d􏷅􏷄start distance􏷃􏵘meters􏵙􏷀the start of the region􏶿
􏶜􏶝􏷆d􏷅􏷄end distance􏷃􏵘meters􏵙􏷀the end of the region􏶿
􏶴
    // create region
    event_region region;
    region.action = event_action_regenerate;
    region.reason = reason;
    region.start_m = start_distance_m;
    region.end_m = end_distance_m;
    
    // store region
    route.event_region_sequence.emplace_back(region);
􏶳
􏴯select some lanes 4􏴰
􏲝Check that we can select lanes and see that they are selected􏲞
􏲛We are no longer able to select lanes (or observe them being selected)􏲜
􏴭
    //ARRANGE
    auto r = create_event_route(create_route_from_lane_distances({5,5,5,5,5}));
    double start_distance_m = 1.0;
    double end_distance_m = 2.0;
    
    //ACT
    set_regeneration_events(r,"test",start_distance_m,end_distance_m);
    
    //ASSERT
    EXPECT_EQ(total_event_regions(r),1);
􏴮
􏱿regular growth􏲀􏱽with_range􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::set_regeneration_events(event_route,"test",0,0)􏱺

􏷘+􏷗􏷒set previous index on route􏷑
􏴅Annotated Route􏴆
􏷐explicitly adjust the previous index used in the evaluation range of the route􏷏
􏶠Ideally, you would create an event route, and adjust the evaluation range by advancing forward
If you need to create the route in a particular state however, you can explicitly set the starting range of evaluation here􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to update progress􏶿
􏶜􏶝􏷆size􏷅􏷄previous lane index􏷃􏷀the index of the previous lane we were non􏶿
􏶴
    route.evaluation_range.previous = previous_lane_index;
􏶳
􏴯we can set the previous index of the routes event window directly􏴰
􏲝we can set the previous index of the routes event window directly􏲞
􏲛setting the previous index on the rout's event window directly does not work􏲜
􏴭
    //ARRANGE
    route r;
    auto event_route = create_event_route(r);
    
    //ACT
    set_previous_index_on_route(event_route,2);
    
    //ASSERT
    EXPECT_EQ((*event_route.evaluation_range.previous),2);
􏴮
􏱿regular growth􏲀􏱽with_range􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::set_previous_index_on_route(event_route,2)􏱺

􏷘+􏷗􏷒set current index on route􏷑
􏴅Annotated Route􏴆
􏷐explicitly adjust the current index used in the evaluation range of the route􏷏
􏶠Ideally, you would create an event route, and adjust the evaluation range by advancing forward
If you need to create the route in a particular state however, you can explicitly set the ending range of evaluation here􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to update progress􏶿
􏶜􏶝􏷆size􏷅􏷄current lane index􏷃􏷀the index of the current lane we were non􏶿
􏶴
    route.evaluation_range.current = current_lane_index;
􏶳
􏴯we can set the current index of the routes event window directly􏴰
􏲝we can set the current index of the routes event window directly􏲞
􏲛setting the current index on the rout's event window directly does not work􏲜
􏴭
    //ARRANGE
    route r;
    auto event_route = create_event_route(r);
    
    //ACT
    set_current_index_on_route(event_route,2);
    
    //ASSERT
    EXPECT_EQ((*event_route.evaluation_range.current),2);
􏴮
􏱿regular growth􏲀􏱽with_range􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::set_current_index_on_route(event_route,2)􏱺







􏷘+􏷗􏷒check invariants􏷑
􏴅Invariant Checks􏴆
􏷐check all of the invariants that we expect to hold about the event route during autonomy within the SLMT􏷏
􏶠these checks are the closest thing we have to requirements
they provide checks on how we think autonomy should be integrating with the regeneration framework
they help ensure that the SLMT is not providing any incorrect data cycle over cycle
these checks can help detect things based on the status of the event route that we would find questionable for autonomy􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to check invariants on􏶿
􏶚m􏶛􏶾event_annotated_route_invariants􏶽􏶼checked invariants􏶻􏲅􏲆􏶺all of he invariants checked􏶹
􏶴
    checked_invariants.evaluation_range_consistent = 􏵲is evaluation range consistent􏵳route);
    checked_invariants.evaluation_range_in_bounds = 􏵲is evaluation range in bounds􏵳route);
    checked_invariants.has_not_jumped_over_1_or_more_lanes = !􏵲jumped over 1 or more lanes􏵳route);
    checked_invariants.has_route_hysteresis = 􏵲has route hysteresis􏵳route);
    checked_invariants.exists_on_or_after_merge_point = !􏵲exists before merge point􏵳route);
    checked_invariants.merge_point_in_bounds = 􏵲merge point in bounds􏵳route);
    checked_invariants.route_has_lanes       = 􏵲has lanes􏵳route);
    checked_invariants.non_single_lane = !􏵲is single lane route􏵳route);
    checked_invariants.all_lanes_have_size = 􏵲lanes have size􏵳route);
􏶳
􏴯slmt example where every invariant holds􏴰
􏲝give an example where the invariant stats returned all pass􏲞
􏲛we are now breaking an invariant on an example of an slmnt route that previously was not􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6,7,8,9,10});
    route_info.merge_point_index = 1; //why we have hysteresis
    route_info.route_changed = false;
    route_info.previous_lane_index = 3;
    route_info.current_lane_index = 4;
    int distance_m = 100;
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ACT
    auto invariants = check_invariants(event_route);
    
    //ASSERT
    EXPECT_TRUE(invariants.evaluation_range_consistent);
    EXPECT_TRUE(invariants.evaluation_range_in_bounds);
    EXPECT_TRUE(invariants.has_not_jumped_over_1_or_more_lanes);
    EXPECT_TRUE(invariants.has_route_hysteresis);
    EXPECT_TRUE(invariants.exists_on_or_after_merge_point);
    EXPECT_TRUE(invariants.merge_point_in_bounds);
    EXPECT_TRUE(invariants.route_has_lanes);
    EXPECT_TRUE(invariants.non_single_lane);
    EXPECT_TRUE(invariants.all_lanes_have_size);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    std::vector<double>                       distances(s.range(0), 10.0f);
    auto                                      route = local_map::statik::create_route_from_lane_distances(distances);
    slmt_route_information route_info;
    route_info.merge_point_index = 1; //why we have hysteresis
    route_info.route_changed = false;
    route_info.previous_lane_index = 3;
    route_info.current_lane_index = 4;
    int distance_m = 100;
    auto event_route = create_slmt_event_route(route, route_info,distance_m);
􏱼
􏱹local_map::statik::check_invariants(event_route)􏱺



routes that are too long
lanes that are too long




􏷘+􏷗􏷒is evaluation range consistent􏷑
􏴅Invariant Checks􏴆
􏷐check that the evaluation range for the event route is logically valid􏷏
􏶠we expect to move through the route from beginning to end
this means that we expect our previous lane index to be <= to our current lane index
this "previous/current index interval" forms the window that we will scan looking for events
as such, we expect our window to be (x,y] such that x <= y
if x > y, we will never process any events (since we scan from x to y)
being in this state is not dangerous from the event route's perspective
it's merely a questionable state from an autonomy perspective
we moved backwards along our route? That debatably shouldn't happen
does this happen in autonomy?
in past implementations, PBM log d617e5bc-3487-48a2-efa4-992d21329e77 shows an interesting case where we are given a new route with a stale "progress"
this results in an interval like [?,6)
(The question select is an indication that we are on a "new route", (since we've never been on that route previously))
the next time we update our lane progress we determine we are actually on the first lane
that transitions the window to [6,0) which is logically inconsistent
our next lane is likely to remain 0, resulting in (0,0], which causes us to skip any events on 0 (because of the open interval)
contractually enforcing that this remains logically consistent can be done using this check
since we are explicitly given our evaluation range from the SLMT, we expose this check to the caller for optional checking and handling of what to do
from an event route's perspective there's no reason you couldn't go forwards or backwards on a route
other people may want to enforce forward progress only􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to check evaluation range on􏶿
􏶚m􏶛􏶾bool􏶽􏶼consistent evaluation range􏶻􏲅false􏲆􏶺whether the evaluation range is valid or not􏶹
􏶴
    if (􏵲is new route􏵳route)){
        consistent_evaluation_range = true;
    }
    else if (􏵲is expired route􏵳route)){
        consistent_evaluation_range = true;
    }
    else if (􏵲is invalid route􏵳route)){
        consistent_evaluation_range = true;
    }
    else if (􏵲is existing route􏵳route)){
        consistent_evaluation_range = *route.evaluation_range.previous <= route.evaluation_range.current;
    }
􏶳
􏴯new route is valid􏴰
􏲝ensure that a new route has a consistent range􏲞
􏲛this should be a valid range when assuming we only move forward through a route􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_consistent(event_route));
􏴮
􏴯expired route is valid􏴰
􏲝ensure that an expired route has a consistent range􏲞
􏲛this should be a valid range when assuming we only move forward through a route􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto event_route = create_event_route(r);
    expire_route(event_route);
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_consistent(event_route));
􏴮
􏴯invalid route is valid􏴰
􏲝ensure that an invalidated route is still a consistent range􏲞
􏲛this should not be invalid range when assuming we only move forward through a route􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto event_route = create_event_route(r);
    invalidate_route(event_route);
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_consistent(event_route));
􏴮
􏴯zero zero is valid􏴰
􏲝ensure that (0,0] is a consistent range􏲞
􏲛this should be a valid range when assuming we only move forward through a route􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,0);
    set_current_index_on_route(route,0);
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_consistent(route));
􏴮
􏴯zero one is valid􏴰
􏲝ensure that (0,1] is a consistent range􏲞
􏲛this should be a valid range when assuming we only move forward through a route􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,0);
    set_current_index_on_route(route,1);
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_consistent(route));
􏴮
􏴯one zero is invalid􏴰
􏲝ensure that (1,0] is an inconsistent range􏲞
􏲛this should not be a valid range when assuming we only move forward through a route􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,1);
    set_current_index_on_route(route,0);
    
    //ASSERT
    EXPECT_FALSE(is_evaluation_range_consistent(route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::is_evaluation_range_consistent(event_route)􏱺

􏷘+􏷗􏷒is evaluation range in bounds􏷑
􏴅Invariant Checks􏴆
􏷐Check that the evaluation range is within bounds of the route􏷏
􏶠the previous lane and the current lane may be outside the current route
we allow this by having optionals on each end of our evaluation range
however, these interval indexes may be set explicitly by the SLMT
In this case, its possible that we are given a lane index that is invalid for the route
We provide and optional check over this invariant􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to check evaluation range on􏶿
􏶚m􏶛􏶾bool􏶽􏶼in bounds􏶻􏲅true􏲆􏶺whether the evaluation range's explicit indexes are in bounds􏶹
􏶴
    if (route.evaluation_range.previous){
        if (!􏵲index in bounds􏵳route,*route.evaluation_range.previous)){
            return false;
        }
    }
    if (route.evaluation_range.current){
        if (!􏵲index in bounds􏵳route,*route.evaluation_range.current)){
            return false;
        }
    }
􏶳
􏴯new empty route has valid bounds􏴰
􏲝ensure that a new route has an evaluation range within bounds of the lane sequence􏲞
􏲛this should be a valid in-bounds evaluation range􏲜
􏴭
    //ARRANGE
    event_annotated_route r;
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_in_bounds(r));
􏴮
􏴯new route has valid bounds􏴰
􏲝ensure that a new route has an evaluation range within bounds of the lane sequence􏲞
􏲛this should be a valid in-bounds evaluation range􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_in_bounds(event_route));
􏴮
􏴯zero zero is valid􏴰
􏲝ensure that (0,0] is an evaluation range within bounds of the lane sequence􏲞
􏲛this should be a valid in-bounds evaluation range􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,0);
    set_current_index_on_route(route,0);
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_in_bounds(route));
􏴮
􏴯zero one is valid􏴰
􏲝ensure that (0,1] is an evaluation range within bounds of the lane sequence􏲞
􏲛this should be a valid in-bounds evaluation range􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,0);
    set_current_index_on_route(route,1);
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_in_bounds(route));
􏴮
􏴯last lane is valid􏴰
􏲝ensure that a range on the last lane is an evaluation range within bounds of the lane sequence􏲞
􏲛this should be a valid in-bounds evaluation range􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,4);
    set_current_index_on_route(route,4);
    
    //ASSERT
    EXPECT_TRUE(is_evaluation_range_in_bounds(route));
􏴮
􏴯last last lane is invalid v1􏴰
􏲝ensure that a range past the last lane is an evaluation range not within bounds of the lane sequence􏲞
􏲛this should be an invalid bounded evaluation range􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,5);
    set_current_index_on_route(route,4);
    
    //ASSERT
    EXPECT_FALSE(is_evaluation_range_in_bounds(route));
􏴮
􏴯last last lane is invalid v2􏴰
􏲝ensure that a range past the last lane is an evaluation range not within bounds of the lane sequence􏲞
􏲛this should be an invalid bounded evaluation range􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,4);
    set_current_index_on_route(route,5);
    
    //ASSERT
    EXPECT_FALSE(is_evaluation_range_in_bounds(route));
􏴮
􏴯last last lane is invalid v3􏴰
􏲝ensure that a range past the last lane is an evaluation range not within bounds of the lane sequence􏲞
􏲛this should be an invalid bounded evaluation range􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,5);
    set_current_index_on_route(route,5);
    
    //ASSERT
    EXPECT_FALSE(is_evaluation_range_in_bounds(route));
􏴮
􏴯negative lane index is invalid v1􏴰
􏲝ensure that a negative lane index is not within bounds of the lane sequence􏲞
􏲛this should be an invalid bounded evaluation range􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,-1);
    set_current_index_on_route(route,0);
    
    //ASSERT
    EXPECT_FALSE(is_evaluation_range_in_bounds(route));
􏴮
􏴯negative lane index is invalid v2􏴰
􏲝ensure that a negative lane index is not within bounds of the lane sequence􏲞
􏲛this should be an invalid bounded evaluation range􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,0);
    set_current_index_on_route(route,-1);
    
    //ASSERT
    EXPECT_FALSE(is_evaluation_range_in_bounds(route));
􏴮
􏴯negative lane index is invalid v3􏴰
􏲝ensure that a negative lane index is not within bounds of the lane sequence􏲞
􏲛this should be an invalid bounded evaluation range􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,-1);
    set_current_index_on_route(route,-1);
    
    //ASSERT
    EXPECT_FALSE(is_evaluation_range_in_bounds(route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::is_evaluation_range_in_bounds(event_route)􏱺

􏷘+􏷗􏷒jumped over 1 or more lanes􏷑
􏴅Invariant Checks􏴆
􏷐Check whether our current lane is two or more lanes greater than our previous lane􏷏
􏶠This would mean that we jumped over a lane
Jumping over a lane is not an error from the regeneration framework perspective
the regeneration framework still processes any events on lanes that we skipped over
We provide it as a check to help evaluate any assumptions about the lane associator
The lag of associating to a lane, may also affect our SLA on available local map
consider this check a soft invariant used to raise awareness about hopping over 1 or more lanes
if the route is invalid (i.e. we don't have a route), this will be false
we'll consider unknown previous locations on the route as the beginning of the route
we'll consider unknown current locations on the route as the end of the route􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route whose lane sequence will be used to check bounds􏶿
􏶚m􏶛􏶾bool􏶽􏶼jumped􏶻􏲅false􏲆􏶺whether or not we jumped over a lane􏶹
􏶴
    if(is_invalid_route(route)){
        return false;
    }
    
    int previous = route.evaluation_range.previous.value_or(0);
    int current = route.evaluation_range.current.value_or(􏵲number of lanes􏵳route));
    jumped = (current-previous > 1);
􏶳

􏴯new empty route does not violate lane hop check􏴰
􏲝ensure that a new empty route does not violate a lane hop check􏲞
􏲛because the route is invalid, we should not be violating the lane hop check􏲜
􏴭
    //ARRANGE
    event_annotated_route r;
    
    //ASSERT
    EXPECT_FALSE(jumped_over_1_or_more_lanes(r));
􏴮
􏴯new route does not violate lane hop check􏴰
􏲝ensure that a new route does not violate a lane hop check􏲞
􏲛because the route is valid, we should be at the beginning of the route and not have hopped lanes􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_FALSE(jumped_over_1_or_more_lanes(event_route));
􏴮
􏴯zero zero is no jump􏴰
􏲝ensure that (0,0] does not violate a lane hop check􏲞
􏲛this is not an evaluation range that shows we skipped over a lane􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,0);
    set_current_index_on_route(route,0);
    
    //ASSERT
    EXPECT_FALSE(jumped_over_1_or_more_lanes(route));
􏴮
􏴯zero one is no jump􏴰
􏲝ensure that (0,1] does not violate a lane hop check􏲞
􏲛this is not an evaluation range that shows we skipped over a lane􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,0);
    set_current_index_on_route(route,1);
    
    //ASSERT
    EXPECT_FALSE(jumped_over_1_or_more_lanes(route));
􏴮
􏴯one three is lane jump􏴰
􏲝ensure that (1,3] is a violation of the lane hop check􏲞
􏲛this is an evaluation range that shows we skipped over a lane􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,1);
    set_current_index_on_route(route,3);
    
    //ASSERT
    EXPECT_TRUE(jumped_over_1_or_more_lanes(route));
􏴮
􏴯more than 1 lane is a violation􏴰
􏲝ensure that (1,4] is a violation of the lane hop check􏲞
􏲛this is an evaluation range that shows we skipped over a lane􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    set_previous_index_on_route(route,1);
    set_current_index_on_route(route,4);
    
    //ASSERT
    EXPECT_TRUE(jumped_over_1_or_more_lanes(route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::jumped_over_1_or_more_lanes(event_route)􏱺

􏷘+􏷗􏷒has route hysteresis􏷑
􏴅Invariant Checks􏴆
􏷐Check whether the SLA event annotated route for SLMT has route hysteresis􏷏
􏶠Assuming the route was selected using the SLA algorithm, we can determine route hysteresis
This is because we select the first logical lane of the route based on our merge point (the current lane index of the route)􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the SLA annotated route from SLMT to evaluate for hysteresis􏶿
􏶚m􏶛􏶾bool􏶽􏶼has route hysteresis􏶻􏲅false􏲆􏶺whether or not the route has hysteresis􏶹
􏶴
    auto lane_index = merge_point(route);
    if (lane_index){
        return *lane_index > 0;
    }
􏶳
􏴯an unannotated route makes it unclear whether there is hysteresis􏴰
􏲝if we didn't annotate the route, we don't know where the merge point is, so we have to assume it doesn't have hysteresis􏲞
􏲛because we can't find an annotated lane in the route, we assume the route does not have hysteresis􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_FALSE(has_route_hysteresis(event_route));
􏴮
􏴯an slmt whose current index starts at 0 does not have hysteresis􏴰
􏲝create a route for the SLMT and determine that it does not have hysteresis􏲞
􏲛we created a route that we believe should not have hysteresis􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6});
    route_info.merge_point_index = 0; //why we don't have hysteresis
    route_info.route_changed = true;
    route_info.previous_lane_index = 0;
    route_info.current_lane_index = 0;
    int distance_m = 100;
    
    //ACT
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ASSERT
    EXPECT_FALSE(has_route_hysteresis(event_route));
􏴮
􏴯an slmt whose current index starts above 1 has hysteresis􏴰
􏲝create a route for the SLMT and determine that it has hysteresis􏲞
􏲛we created a route that we believe should have hysteresis􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6});
    route_info.merge_point_index = 1; //why we have hysteresis
    route_info.route_changed = true;
    route_info.previous_lane_index = 3;
    route_info.current_lane_index = 3;
    int distance_m = 100;
    
    //ACT
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ASSERT
    EXPECT_TRUE(has_route_hysteresis(event_route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::has_route_hysteresis(event_route)􏱺

􏷘+􏷗􏷒exists before merge point􏷑
􏴅Invariant Checks􏴆
􏷐check to see if we've existing on the route before the merge point􏷏
􏶠have we ever been or claimed to be on the current route's portion of hysteresis?􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the SLA annotated route from SLMT􏶿
􏶚m􏶛􏶾bool􏶽􏶼existed before merge point􏶻􏲅false􏲆􏶺we have been somewhere on the route before the merge point􏶹
􏶴
    auto lane_index = 􏵲merge point􏵳route);
    
    //if we don't have a merge point that means we have no hysteresis
    //which means we can't be behind the merge point and on the hysteresis part of the route
    if (lane_index){
        if (route.evaluation_range.previous){
            if (*route.evaluation_range.previous < *lane_index){
                return true;
            }
        }
        if (route.evaluation_range.current){
            if (*route.evaluation_range.current < *lane_index){
                return true;
            }
        }
    }
􏶳
􏴯evaluation window on slmnt is ahead of merge point pass invariant􏴰
􏲝we are in front of the merge point􏲞
􏲛we should be building an event route that should be ahead of merge point􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6});
    route_info.merge_point_index = 1; //why we have hysteresis
    route_info.route_changed = true;
    route_info.previous_lane_index = 3;
    route_info.current_lane_index = 3;
    int distance_m = 100;
    
    //ACT
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ASSERT
    EXPECT_FALSE(exists_before_merge_point(event_route));
􏴮
􏴯evaluation window on slmnt is behind the merge point failed invariant􏴰
􏲝we are behind the merge point􏲞
􏲛we should be building an event route that is behind the merge point􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6,7,8,9});
    route_info.merge_point_index = 4; //why we have hysteresis
    route_info.route_changed = false;
    route_info.previous_lane_index = 2;
    route_info.current_lane_index = 5;
    int distance_m = 1;
    
    //ACT
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ASSERT
    EXPECT_TRUE(exists_before_merge_point(event_route));
􏴮
􏴯evaluation window on slmnt is behind the merge point failed invariant two􏴰
􏲝we are behind the merge point􏲞
􏲛we should be building an event route that is behind the merge point􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6,7,8,9});
    route_info.merge_point_index = 4; //why we have hysteresis
    route_info.route_changed = false;
    route_info.previous_lane_index = 5;
    route_info.current_lane_index = 2;
    int distance_m = 1;
    
    //ACT
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ASSERT
    EXPECT_TRUE(exists_before_merge_point(event_route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::exists_before_merge_point(event_route)􏱺

􏷘+􏷗􏷒merge point in bounds􏷑
􏴅Invariant Checks􏴆
􏷐check whether the derived merge point is in the bounds of the route􏷏
􏶠if there is no merge point found, we consider its absence to be in bounds􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to check invariant on􏶿
􏶚m􏶛􏶾bool􏶽􏶼in bounds􏶻􏲅true􏲆􏶺whether the merge point (if it exists at all) is in bounds or not􏶹
􏶴
    auto lane_index = 􏵲merge point􏵳route);
    if (lane_index){
        if (!􏵲index in bounds􏵳route,*lane_index)){
            return false;
        }
    }
􏶳
􏴯create an event route with a valid merge point􏴰
􏲝make sure the invariant passes􏲞
􏲛the merge point is in bounds so the invariant should not be failing􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6,7,8,9});
    route_info.merge_point_index = 1; //why we have hysteresis
    route_info.route_changed = false;
    route_info.previous_lane_index = 2;
    route_info.current_lane_index = 1;
    int distance_m = 1;
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ACT
    auto in_bounds = merge_point_in_bounds(event_route);
    
    //ASSERT
    EXPECT_TRUE(in_bounds);
􏴮
􏴯create an event route with an invalid merge point􏴰
􏲝this is not possible􏲞
􏲛it is not possible to create an event route with an invalid merge point􏲜
􏴭
    // the merge point is currently discovered by finding
    // the first lane along the route that is selected.
    // Since we assume that the SLA algorithm will always select the first
    // lane, we find it by scanning the lanes.
    // this means the merge point is either a valid lane, or it doesn't exist.
    // Therefore, we can't create a scenario based on the current implementation of merge point discovery where this invariant would fail.  
    // This also means we can't get code coverage for a failed invariant (without other implementations changing).
    // We might consider being more explicit about what the merge point is in the event route.  
    // Currently we are given the merge point as the starting point of our marking algorithm,
    // which in turn marks the first lane.. making it then discovered later as derivable merge point.
    // If an out of range merge point is given now, it is constrained to the route when running the marking algorithm.  
    // To prove this:
    
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6,7,8,9});
    route_info.merge_point_index = 100; //merge point outside
    route_info.route_changed = false;
    route_info.previous_lane_index = 0;
    route_info.current_lane_index = 3;
    int distance_m = 1;
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ACT
    auto in_bounds = merge_point_in_bounds(event_route);
    
    //ASSERT
    //(we may want to consider this FALSE instead)
    EXPECT_TRUE(in_bounds);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::merge_point_in_bounds(event_route)􏱺

􏷘+􏷗􏷒lanes have size􏷑
􏴅Invariant Checks􏴆
􏷐ensure that all of the lanes have a valid size􏷏
􏶠if the distance of any lane is found to be negative or 0 we return false􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to check invariant on􏶿
􏶚m􏶛􏶾bool􏶽􏶼valid distances􏶻􏲅true􏲆􏶺whether all the lanes are a valid distance􏶹
􏶴
    for (size_t i = 0; i < 􏵲number of lanes􏵳route); ++i){
        if (􏵲lane length􏵳route,i) <= 0){
            return false;
        }
    }
􏶳
􏴯all valid distances􏴰
􏲝create a route of all valid distances and ensure it passes the invariant􏲞
􏲛the route was created with valid distances yet it is failing the distance check􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_lane_distances({1,20,1000,.5});
    
    //ACT
    auto valid_sizes = lanes_have_size(route);
    
    //ASSERT
    EXPECT_TRUE(valid_sizes);
􏴮
􏴯no_distances pass􏴰
􏲝create a route with no lanes and ensure it passes the invariant􏲞
􏲛the route was created with no lanes so it should pass the distance check􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_lane_distances({});
    
    //ACT
    auto valid_sizes = lanes_have_size(route);
    
    //ASSERT
    EXPECT_TRUE(valid_sizes);
􏴮
􏴯an invalid distance zero􏴰
􏲝create a route with an invalid distance and ensure it fails the invariant􏲞
􏲛the route was created with an invalid distance yet it is still passing the distance check somehow􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_lane_distances({1,20,0,1000,.5});
    
    //ACT
    auto valid_sizes = lanes_have_size(route);
    
    //ASSERT
    EXPECT_FALSE(valid_sizes);
􏴮
􏴯an invalid distance negative􏴰
􏲝create a route with an invalid distance and ensure it fails the invariant􏲞
􏲛the route was created with an invalid distance yet it is still passing the distance check somehow􏲜
􏴭
    //ARRANGE
    auto route = create_event_route_from_lane_distances({1,20,-1,1000,.5});
    
    //ACT
    auto valid_sizes = lanes_have_size(route);
    
    //ASSERT
    EXPECT_FALSE(valid_sizes);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::lanes_have_size(event_route)􏱺











􏷘-􏷗􏷒merge point􏷑
􏴅Detail􏴆
􏷐find the logical first lane which represents the start of the route􏷏
􏶠The merge point is the lane after hysteresis
Assumes you are using an event route created for the SLMT􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to find the merge point on􏶿
􏶚m?􏶛􏶾size􏶽􏶼merge point􏶻􏲅􏲆􏶺the first lane after hysteresis representing the merge point􏶹
􏶴
    //since we always select the first logical lane with SLMT SLA algorithm (i.e. the merge point),
    //we can assume that the first selected lane is the merge point
    //if we need to store the merge point explicitly later, we can do that
    //for now, we derive it as followed
    return first_lane_index_with_an_event(route);
􏶳

􏷘-􏷗􏷒first lane index with an event􏷑
􏴅Detail􏴆
􏷐Check that the index is within bounds of the route's lane sequence􏷏
􏶠returns true if it is in bounds; false otherwise􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route whose lane sequence will be used to check bounds􏶿
􏶚m?􏶛􏶾size􏶽􏶼lane index with event􏶻􏲅􏲆􏶺the first lane of the route with an event􏶹
􏶴
    for (size_t i = 0; i < 􏵲number of lanes􏵳route); ++i){
        if (!route.event_lane_sequence[i].event_sequence.empty()){
            lane_index_with_event = i;
            break;
        }
    }
􏶳

􏷘-􏷗􏷒index in bounds􏷑
􏴅Detail􏴆
􏷐Check that the index is within bounds of the route's lane sequence􏷏
􏶠returns true if it is in bounds; false otherwise􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route whose lane sequence will be used to check bounds􏶿
􏶜􏶝􏷆size􏷅􏷄lane index􏷃􏷀the lane index we are checking to see is in bounds􏶿
􏶚m􏶛􏶾bool􏶽􏶼in bounds􏶻􏲅false􏲆􏶺whether the lane index provided is within bounds􏶹
􏶴
    if (lane_index >= 0 && lane_index < 􏵲number of lanes􏵳route)){
        return true;
    }
􏶳

􏷘+􏷗􏷒advance forward on route􏷑
􏴅Annotated Route􏴆
􏷐extends the processing view forward to the current lane provided􏷏
􏶠The previous current lane becomes the start of the event view
This way we won't skip any lanes when evaluating for regeneration events􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to update progress􏶿
􏶜􏶝􏷆size􏷅􏷄current lane index􏷃􏷀the index of the current lane we are on􏶿
􏶴
    route.evaluation_range.previous = route.evaluation_range.current;
    route.evaluation_range.current = current_lane_index;
􏶳
􏴯check forward progressing of route􏴰
􏲝as we progress forward on the route, check that our previous and current index update correctly􏲞
􏲛moving forward along the route does not increment previous/current indexes correctly􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto event_route = create_event_route(r);
    advance_forward_on_route(event_route,1);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(0,1]");
    
    //ACT
    advance_forward_on_route(event_route,2);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(1,2]");
    
    //ACT
    advance_forward_on_route(event_route,2);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(2,2]");
    
    //ACT
    advance_forward_on_route(event_route,4);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(2,4]");
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::advance_forward_on_route(event_route,1)􏱺

􏷘+􏷗􏷒expire route􏷑
􏴅Annotated Route􏴆
􏷐extends the processing view forward to the end of the route􏷏
􏶠If we have finished the route or have transitioned to a new route, we may still want to process events along the remainder of the previous route
Expiring the route sets a processing view that will allow process to the end despite specifying a lane index􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to update progress􏶿
􏶴
    route.evaluation_range.previous = route.evaluation_range.current;
    route.evaluation_range.current = stdx::nullopt;
􏶳
􏴯expiring a route makes the current index unknown􏴰
􏲝when we expire a route, ensure that the current index becomes unknown􏲞
􏲛expiring a route is no longer giving the expected event window􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto event_route = create_event_route(r);
    advance_forward_on_route(event_route,1);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(0,1]");
    
    //ACT
    expire_route(event_route);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(1,?]");
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::expire_route(event_route)􏱺

􏷘+􏷗􏷒invalidate route􏷑
􏴅Annotated Route􏴆
􏷐select the route as invalidated􏷏
􏶠This invalidates the processing window, interpreting the route as invalid
There may be reasons outside the scope of the annotating a route API, that you may want to invalidate an annotated route
Calling this function will ensure that interpret_route_status returns route_status_invalid􏶡
􏶜rm􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to invalidate􏶿
􏶴
    route.evaluation_range.previous = stdx::nullopt;
    route.evaluation_range.current = stdx::nullopt;
􏶳
􏴯invalidating a route makes the entire event window unknown􏴰
􏲝when we invalidate a route, ensure that both indexes of the event window become unknown􏲞
􏲛invalidating a route is no longer giving the expected event window􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto event_route = create_event_route(r);
    advance_forward_on_route(event_route,1);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(0,1]");
    
    //ACT
    invalidate_route(event_route);
    
    //ASSERT
    EXPECT_EQ(event_range_as_string(event_route),"(?,?]");
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::invalidate_route(event_route)􏱺

􏷘+􏷗􏷒is existing route􏷑
􏴅Annotated Route􏴆
􏷐Checks whether the route we are on has existed since the previous event window adjustment􏷏
􏶠Uses the event window to interpret the route status􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze the status of􏶿
􏶚m􏶛􏶾bool􏶽􏶼is existing􏶻􏲅(route.evaluation_range.previous && route.evaluation_range.current)􏲆􏶺whether the route is already existing or not􏶹
􏶴􏶳
􏴯moving forward on a route transitions it to existing􏴰
􏲝Moving forward on a route transitions it to an existing route􏲞
􏲛Moving forward did not transition the route to an existing route􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4});
    
    //ACT
    auto event_route = create_event_route(r);
    advance_forward_on_route(event_route,1);
    
    //ASSERT
    EXPECT_TRUE(is_existing_route(event_route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::is_existing_route(event_route)􏱺

􏷘+􏷗􏷒is new route􏷑
􏴅Annotated Route􏴆
􏷐Checks whether the route is new, and the event window has yet to be adjusted􏷏
􏶠Uses the event window to interpret the route status􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze the status of􏶿
􏶚m􏶛􏶾bool􏶽􏶼is new􏶻􏲅(!route.evaluation_range.previous && route.evaluation_range.current)􏲆􏶺whether the route is new or not􏶹
􏶴􏶳
􏴯converting a route makes it new􏴰
􏲝Converting a route makes its status new (since we don't have any previous indexes)􏲞
􏲛Converting a route did not make it new􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4});
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_TRUE(is_new_route(event_route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::is_new_route(event_route)􏱺


􏷘+􏷗􏷒is expired route􏷑
􏴅Annotated Route􏴆
􏷐Checks to see if the route has expired meaning we are now past the end of the route􏷏
􏶠Uses the event window to interpret the route status􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze the status of􏶿
􏶚m􏶛􏶾bool􏶽􏶼is expired􏶻􏲅(route.evaluation_range.previous && !route.evaluation_range.current)􏲆􏶺whether the route is expired or not􏶹
􏶴􏶳
􏴯expiring a route makes it expired􏴰
􏲝Expiring a route makes it expired􏲞
􏲛Expiring a route still returns false when checking if its expired􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4});
    
    //ACT
    auto event_route = create_event_route(r);
    expire_route(event_route);
    
    //ASSERT
    EXPECT_TRUE(is_expired_route(event_route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::is_expired_route(event_route)􏱺

􏷘+􏷗􏷒is invalid route􏷑
􏴅Annotated Route􏴆
􏷐Checks to see if the route is invalidated warranting that events can not be processed on it􏷏
􏶠Uses the event window to interpret the route status􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze the status of􏶿
􏶚m􏶛􏶾bool􏶽􏶼is invalid􏶻􏲅(!route.evaluation_range.previous && !route.evaluation_range.current)􏲆􏶺whether the route is invalid or not􏶹
􏶴􏶳
􏴯invalidating a route makes it invalid􏴰
􏲝invalidating a route makes it invalid􏲞
􏲛invalidating a route still returns false when checking if its invalid􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4});
    
    //ACT
    auto event_route = create_event_route(r);
    invalidate_route(event_route);
    
    //ASSERT
    EXPECT_TRUE(is_invalid_route(event_route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::is_invalid_route(event_route)􏱺

􏷘+􏷗􏷒interpret route status􏷑
􏴅Annotated Route􏴆
􏷐interpret the status of the route by observing the range of lanes that need evaluated􏷏
􏶠Based on the status of lanes that need evaluated, we can derive some contextual information about the route􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze the status of􏶿
􏶚m􏶛􏶾route_status􏶽􏶼route interpretation􏶻􏲅route_status_invalid􏲆􏶺an interpretation about the status of the route􏶹
􏶴
    􏶲(n,n) = existing route􏶱
    if (􏵲is existing route􏵳route)){
        route_interpretation = route_status_existing;
    }
    
    􏶲(?,n) = new route􏶱
    else if(􏵲is new route􏵳route)){
        route_interpretation = route_status_new;
    }
    
    􏶲(n,?) = expired route􏶱
    else if(􏵲is expired route􏵳route)){
        route_interpretation = route_status_expired;
    }
    
    􏶲(?,?) = invalid route􏶱
    else if(􏵲is invalid route􏵳route)){
        route_interpretation = route_status_invalid;
    }
􏶳
􏴯converting a route makes it new􏴰
􏲝Converting a route makes its status new (since we don't have any previous indexes)􏲞
􏲛Converting a route did not make it new􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4});
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_new);
􏴮
􏴯walk though route status􏴰
􏲝We should be able to transition the status from new, to current, to expired􏲞
􏲛Status is not correct when transitioning the status of a route􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4});
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_new);
    
    //ACT
    advance_forward_on_route(event_route,1);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_existing);
    
    //ACT
    advance_forward_on_route(event_route,2);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_existing);
    
    //ACT
    expire_route(event_route);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_expired);
    
    //ACT
    invalidate_route(event_route);
    
    //ASSERT
    EXPECT_EQ(interpret_route_status(event_route),route_status_invalid);
􏴮
􏴯walk though route status with explicit checking􏴰
􏲝We should be able to transition the status from new, to current, to expired􏲞
􏲛Status is not correct when transitioning the status of a route􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4});
    
    //ACT
    auto event_route = create_event_route(r);
    
    //ASSERT
    EXPECT_TRUE(is_new_route(event_route));
    EXPECT_FALSE(is_existing_route(event_route));
    EXPECT_FALSE(is_expired_route(event_route));
    EXPECT_FALSE(is_invalid_route(event_route));
    
    //ACT
    advance_forward_on_route(event_route,1);
    
    //ASSERT
    EXPECT_FALSE(is_new_route(event_route));
    EXPECT_TRUE(is_existing_route(event_route));
    EXPECT_FALSE(is_expired_route(event_route));
    EXPECT_FALSE(is_invalid_route(event_route));
    
    //ACT
    advance_forward_on_route(event_route,2);
    
    //ASSERT
    EXPECT_FALSE(is_new_route(event_route));
    EXPECT_TRUE(is_existing_route(event_route));
    EXPECT_FALSE(is_expired_route(event_route));
    EXPECT_FALSE(is_invalid_route(event_route));
    
    //ACT
    expire_route(event_route);
    
    //ASSERT
    EXPECT_FALSE(is_new_route(event_route));
    EXPECT_FALSE(is_existing_route(event_route));
    EXPECT_TRUE(is_expired_route(event_route));
    EXPECT_FALSE(is_invalid_route(event_route));

    //ACT
    invalidate_route(event_route);
    
    //ASSERT
    EXPECT_FALSE(is_new_route(event_route));
    EXPECT_FALSE(is_existing_route(event_route));
    EXPECT_FALSE(is_expired_route(event_route));
    EXPECT_TRUE(is_invalid_route(event_route));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::interpret_route_status(event_route)􏱺

􏷘+􏷗􏷒should regenerate􏷑
􏴅Annotated Route􏴆
􏷐determines whether we should regenerate􏷏
􏶠Uses the internal event view to process over lanes􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze for regeneration􏶿
􏶚m􏶛􏶾bool􏶽􏶼should regenerate􏶻􏲅false􏲆􏶺whether we should regenerate based on our current progress􏶹
􏶴
    􏶲we should never regenerate on a route without lanes􏶱
    if (!􏵲has lanes􏵳route)){
        return false;
    }
    
    􏶲we should never regenerate when the route is invalid􏶱
    if (􏵲is invalid route􏵳route)){
        return false;
    }

    􏶲if we already processed the last lane index in the route,􏶱
    􏶲then there is nothing to regenerate􏶱
    if (route.evaluation_range.previous){
        if (*route.evaluation_range.previous == 􏵲last lane index􏵳route)){
            return false;
        }
    }

    􏶲get index interval to check for events on􏶱
    size_t start_index = 􏵲first index to process􏵳route);
    size_t end_index = 􏵲last index to process􏵳route);
    
    for (size_t i = start_index; i <= end_index; ++i){
        if (i <= 􏵲last lane index􏵳route)){
            if (!route.event_lane_sequence[i].event_sequence.empty()){
                return true;
            }
        }
        else
        {
            return true;
        }
    } 

􏶳
􏴯invalid route cant regenerate􏴰
􏲝If the route is invalid, it can't be used to regenerate􏲞
􏲛An invalid route is allowing regenerations and it should not􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    invalidate_route(event_route);
    
    //ASSERT
    EXPECT_FALSE(should_regenerate(event_route));
􏴮
􏴯valid new route can regenerate􏴰
􏲝If the route is valid and new, we can regenerate􏲞
􏲛The route is valid and new yet we are deciding not to regenerate􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    set_previous_index_on_route(event_route, 0);
    set_current_index_on_route(event_route, 999);
    
    //ASSERT
    EXPECT_TRUE(should_regenerate(event_route));
􏴮
􏴯out of bounds evaluation range can regenerate􏴰
􏲝If the route is valid and new, we can regenerate􏲞
􏲛The route is valid and new yet we are deciding not to regenerate􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,999);
    
    //ASSERT
    EXPECT_TRUE(should_regenerate(event_route));
􏴮
􏴯no lanes should not regenerate􏴰
􏲝If the route has no lanes, we should never regenerate􏲞
􏲛The route has no lanes, yet we are saying to regenerate􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_submap_ids({});
    
    //ACT
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,999);
    
    //ASSERT
    EXPECT_FALSE(should_regenerate(event_route));
􏴮
􏴯last lane already evaluated should not regenerate􏴰
􏲝if we've already evaluated the last lane, we should not regenerate again􏲞
􏲛for some reason we are choosing to regenerate despite the last lane having already been evaluated􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_submap_ids({1,2,3,4,5,6});
    
    //ACT
    set_previous_index_on_route(event_route,5);
    set_current_index_on_route(event_route,5);
    
    //ASSERT
    EXPECT_FALSE(should_regenerate(event_route));
􏴮
􏴯valid route but no markings should not regenerate􏴰
􏲝Test that we can process lanes for regeneration but not regenerate if none of them are marked􏲞
􏲛The route is valid and there are lanes to process, yet we should not be attempting to regenerate, because there is no markings􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_submap_ids({1,2,3,4,5,6});
    
    //ACT
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,5);
    
    //ASSERT
    EXPECT_FALSE(should_regenerate(event_route));
􏴮


􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::should_regenerate(event_route)􏱺

􏷘+􏷗􏷒current lanes with annotations􏷑
􏴅Annotated Route􏴆
􏷐get back the lane indexes of the current lanes under evaluation that have annotations􏷏
􏶠Uses the event view to iterate over a window of lanes and return the ones that have annotations􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get annotated lane indexes from􏶿
􏶚m􏶛􏶾ordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route's event view􏶹
􏶴
    􏶲get index interval to check for events on􏶱
    if (!􏵲is invalid route􏵳route)){
        size_t start_index = 􏵲first index to process􏵳route);
        size_t end_index = 􏵲last index to process􏵳route);
        
        for (size_t i = start_index; i < end_index; ++i){
            if (!route.event_lane_sequence[i].event_sequence.empty()){
                lane_indexes.emplace_back(i);
            }
        }
    }
􏶳
􏴯invalid route has no annotated lanes􏴰
􏲝If the route is invalid, we don't have any annotated lanes􏲞
􏲛An invalid route is invalid so we shouldn't have any current lanes􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    invalidate_route(event_route);
    auto lane_indexes = current_lanes_with_annotations(event_route);
    
    //ASSERT
    EXPECT_TRUE(lane_indexes.empty());
􏴮
􏴯valid new route has the lane annotated􏴰
􏲝If the route is valid and new, we will detect our lane as annotated􏲞
􏲛The route is valid and new yet we are no longer detecting the annotated lane􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    set_current_index_on_route(event_route, 1);
    auto lane_indexes = current_lanes_with_annotations(event_route);
    
    //ASSERT
    EXPECT_EQ(lane_indexes.size(),1);
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),0) != lane_indexes.end());
􏴮
􏴯out of bounds evaluation range finds all annotated lanes through fitting􏴰
􏲝Given a full range, we will find all of the annotated lanes􏲞
􏲛Given a full range, we are no longer discovering that all of the lanes are annotated􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,999);
    auto lane_indexes = current_lanes_with_annotations(event_route);
    
    //ASSERT
    EXPECT_EQ(lane_indexes.size(),5);
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),0) == lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),1) != lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),2) != lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),3) != lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),4) != lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),5) != lane_indexes.end());
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::current_lanes_with_annotations(event_route)􏱺



􏷘+􏷗􏷒current lane guids with annotations􏷑
􏴅Annotated Route􏴆
􏷐get back the lane guids of the current lanes under evaluation that have annotations􏷏
􏶠Uses the event view to iterate over a window of lanes and return the ones that have annotations􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get annotated lane guids from􏶿
􏶚m􏶛􏶾ordered_guids􏶽􏶼lane guids􏶻􏶺selected lanes along the route's event view􏶹
􏶴
    auto indexes = 􏵲current lanes with annotations􏵳route);
    for (auto index: indexes){
        lane_guids.emplace_back(route.event_lane_sequence[index].info.map_ref.element_id);
    }
􏶳
􏴯invalid route has no annotated lanes􏴰
􏲝If the route is invalid, we don't have any annotated lanes􏲞
􏲛An invalid route is invalid so we shouldn't have any current lanes􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    invalidate_route(event_route);
    auto lane_guids = current_lane_guids_with_annotations(event_route);
    
    //ASSERT
    EXPECT_TRUE(lane_guids.empty());
􏴮
􏴯valid new route has the first lane annotated􏴰
􏲝If the route is valid and new, we will detect our first lane as annotated􏲞
􏲛The route is valid and new yet we are no longer detecting the first annotated lane􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    set_current_index_on_route(event_route, 1);
    auto lane_guids = current_lane_guids_with_annotations(event_route);
    
    //ASSERT
    EXPECT_EQ(lane_guids.size(),1);
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(1)) != lane_guids.end());
􏴮
􏴯out of bounds evaluation range finds all annotated lanes through fitting􏴰
􏲝Given a full range, we will find all of the annotated lanes􏲞
􏲛Given a full range, we are no longer discovering that all of the lanes are annotated􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,999);
    auto lane_guids = current_lane_guids_with_annotations(event_route);
    
    //ASSERT
    EXPECT_EQ(lane_guids.size(),5);
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(1)) == lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(2)) != lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(3)) != lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(4)) != lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(5)) != lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(6)) != lane_guids.end());
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::current_lane_guids_with_annotations(event_route)􏱺


􏷘+􏷗􏷒all lanes with annotations􏷑
􏴅Annotated Route􏴆
􏷐get back any of the lane indexes that have annotations􏷏
􏶠iterates over lanes and return the ones that have annotations􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get annotated lane indexes from􏶿
􏶚m􏶛􏶾ordered_indexes􏶽􏶼lane indexes􏶻􏶺selected lanes along the route􏶹
􏶴
    for (size_t i = 0; i < 􏵲number of lanes􏵳route); ++i){
        if (!route.event_lane_sequence[i].event_sequence.empty()){
            lane_indexes.emplace_back(i);
        }
    }
􏶳
􏴯selecting all lanes gives back all lanes􏴰
􏲝selecting all of the lanes gives back all of the lanes􏲞
􏲛Some of the lanes are not being returned􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    auto lane_indexes = all_lanes_with_annotations(event_route);
    
    //ASSERT
    EXPECT_EQ(lane_indexes.size(),6);
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),0) != lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),1) != lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),2) != lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),3) != lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),4) != lane_indexes.end());
    EXPECT_TRUE(std::find(lane_indexes.begin(),lane_indexes.end(),5) != lane_indexes.end());
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::all_lanes_with_annotations(event_route)􏱺


􏷘+􏷗􏷒all lane guids with annotations􏷑
􏴅Annotated Route􏴆
􏷐get back any of the lane guids that have annotations􏷏
􏶠iterates over lanes and return the ones that have annotations􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get annotated lane guids from􏶿
􏶚m􏶛􏶾ordered_guids􏶽􏶼lane guids􏶻􏶺selected lanes along the route􏶹
􏶴
    for (size_t i = 0; i < 􏵲number of lanes􏵳route); ++i){
        if (!route.event_lane_sequence[i].event_sequence.empty()){
            lane_guids.emplace_back(route.event_lane_sequence[i].info.map_ref.element_id);
        }
    }
􏶳
􏴯selecting all lanes gives back all lanes􏴰
􏲝selecting all of the lanes gives back all of the lanes􏲞
􏲛Some of the lanes are not being returned􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_ids({1,2,3,4,5,6});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    auto lane_guids = all_lane_guids_with_annotations(event_route);
    
    //ASSERT
    EXPECT_EQ(lane_guids.size(),6);
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(1)) != lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(2)) != lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(3)) != lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(4)) != lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(5)) != lane_guids.end());
    EXPECT_TRUE(std::find(lane_guids.begin(),lane_guids.end(),hub::base::guid::from_int64(6)) != lane_guids.end());
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
􏱼
􏱹local_map::statik::all_lane_guids_with_annotations(event_route)􏱺


􏷘+􏷗􏷒markers exist on current lane􏷑
􏴅Annotated Route􏴆
􏷐determines whether the current lane has selecters􏷏
􏶠This does not take into account the previous lane that was analyzed􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze for selecters􏶿
􏶚m􏶛􏶾bool􏶽􏶼has selecters􏶻􏲅false􏲆􏶺whether there are selecters on the current lane􏶹
􏶴
    if (*route.evaluation_range.current < route.event_lane_sequence.size())
    {
        if (!route.event_lane_sequence[*route.evaluation_range.current].event_sequence.empty())
        {
            return true;
        }
    }
􏶳
􏴯lane without annotation􏴰
􏲝make our current lane a lane without an annotation; no selecters􏲞
􏲛We are claiming there is a selecter on the lane when there should be􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_specific_lane_index(r,2);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    set_current_index_on_route(event_route,3);
    auto exists = markers_exist_on_current_lane(event_route);
    
    //ASSERT
    EXPECT_FALSE(exists);
􏴮
􏴯lane with annotation􏴰
􏲝make our current lane a lane with an annotation; has selecters􏲞
􏲛We are claiming there is no selecter on the lane when there should be􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_specific_lane_index(r,2);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    set_current_index_on_route(event_route,2);
    auto exists = markers_exist_on_current_lane(event_route);
    
    //ASSERT
    EXPECT_TRUE(exists);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::markers_exist_on_current_lane(event_route)􏱺


􏷘+􏷗􏷒inside event region􏷑
􏴅Annotated Route􏴆
􏷐determines whether the current position is in an event region􏷏
􏶠True if we are; False if we are not􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze for event regions􏶿
􏶚m􏶛􏶾bool􏶽􏶼within region􏶻􏲅false􏲆􏶺whether we are within an event region􏶹
􏶴
    //TODO(thickey): use distance granularity (make event window from distance; not index)
    if (route.evaluation_range.current){
        if (*route.evaluation_range.current < route.event_lane_sequence.size())
        {
            auto current_distance_m = 􏵲lane index to distance􏵳route,*route.evaluation_range.current);
            for (const auto & it: route.event_region_sequence){
                if (it.start_m <= current_distance_m && it.end_m >= current_distance_m){
                    return true;
                }
            }
        }
    }
􏶳
􏴯check inside event region􏴰
􏲝moving into the event region will ensure we are inside the event region􏲞
􏲛We set an event region and moved into it, but it says we are not in it􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({10,10,10,10,10,10});
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,"test",10,20);
    
    //ACT
    set_current_index_on_route(event_route,1);
    auto inside = inside_event_region(event_route);
    
    //ASSERT
    EXPECT_TRUE(inside);
􏴮
􏴯check outside event region􏴰
􏲝moving outside the event region will ensure we are not inside the event region􏲞
􏲛We set an event region and move outside it it, but it says we are in it􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({10,10,10,10,10,10});
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,"test",10,20);
    
    //ACT
    set_current_index_on_route(event_route,3);
    auto inside = inside_event_region(event_route);
    
    //ASSERT
    EXPECT_FALSE(inside);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::inside_event_region(event_route)􏱺


􏷘+􏷗􏷒inside event region􏷑
􏴅Annotated Route􏴆
􏷐determines whether the current position is in an event region􏷏
􏶠True if we are; False if we are not􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze for event regions􏶿
􏶜􏶝􏷆d􏷅􏷄current distance􏷃􏵘meters􏵙􏷀the distance to to traverse the route with to find the corresponding lane􏶿
􏶚m􏶛􏶾bool􏶽􏶼within region􏶻􏲅false􏲆􏶺whether we are within an event region􏶹
􏶴
    for (const auto & it: route.event_region_sequence){
        if (it.start_m <= current_distance_m && it.end_m >= current_distance_m){
            return true;
        }
    }
􏶳
􏴯check inside event region with distance􏴰
􏲝moving into the event region will ensure we are inside the event region􏲞
􏲛We set an event region and moved into it, but it says we are not in it􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({10,10,10,10,10,10});
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,"test",10,20);
    
    //ACT
    auto inside = inside_event_region(event_route,15);
    
    //ASSERT
    EXPECT_TRUE(inside);
􏴮
􏴯check outside event region with distance􏴰
􏲝moving outside the event region will ensure we are not inside the event region􏲞
􏲛We set an event region and move outside it it, but it says we are in it􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({10,10,10,10,10,10});
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,"test",10,20);
    
    //ACT
    auto inside = inside_event_region(event_route,21);
    
    //ASSERT
    EXPECT_FALSE(inside);
􏴮
􏱿regular growth􏲀􏱽with_distance􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::inside_event_region(event_route,10)􏱺


􏷘+􏷗􏷒total event markings􏷑
􏴅Annotated Route􏴆
􏷐the total number of events that exist along the route􏷏
􏶠calculates the total number of events across lanes over the route
does not count "event regions"; only "event selecters"􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to calculate event markings over􏶿
􏶚m􏶛􏶾i􏶽􏶼total_event_markings􏶻􏲅0􏲆􏶺the total number of event markings across the lanes over the route􏶹
􏶴
    for (const auto & lane: route.event_lane_sequence){
        total_event_markings += lane.event_sequence.size();
    }
􏶳
􏴯no events􏴰
􏲝check that a route with no events has no events􏲞
􏲛The new route somehow has events􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto event_route = create_event_route(r);
    
    //ACT
    auto amount = total_event_markings(event_route);
    
    //ASSERT
    EXPECT_EQ(amount,0);
􏴮
􏴯multiple events on the same lane􏴰
􏲝check that a route can have multiple events on the same lane􏲞
􏲛The route does not have the expected number of events􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto indexes = select_specific_lane_index(r,2);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test 1");
    set_regeneration_events(event_route,indexes,"test 2");
    set_regeneration_events(event_route,indexes,"test 3");
    
    //ACT
    auto amount = total_event_markings(event_route);
    
    //ASSERT
    EXPECT_EQ(amount,3);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::total_event_markings(event_route)􏱺


􏷘+􏷗􏷒total event regions􏷑
􏴅Annotated Route􏴆
􏷐the total number of event regions that exist along the route􏷏
􏶠calculates the total number of event regions across lanes of the route
does not count "event selecters"; only "event regions"􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to calculate event regions over􏶿
􏶚m􏶛􏶾i􏶽􏶼total_event_regions􏶻􏲅route.event_region_sequence.size()􏲆􏶺the total number of event regions across the lanes of the route􏶹
􏶴􏶳
􏴯no event regions􏴰
􏲝check that a route with no event regions has no event regions􏲞
􏲛The new route somehow has event regions􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5,6});
    auto event_route = create_event_route(r);
    
    //ACT
    auto amount = total_event_regions(event_route);
    
    //ASSERT
    EXPECT_EQ(amount,0);
􏴮
􏴯multiple event regions on the same lane􏴰
􏲝check that a route can have multiple event regions on the same lane􏲞
􏲛The route does not have the expected number of event regions􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({10,10,10,10,10,10});
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,"test 1",10,20);
    set_regeneration_events(event_route,"test 2",15,25);
    set_regeneration_events(event_route,"test 3",20,30);
    
    //ACT
    auto amount = total_event_regions(event_route);
    
    //ASSERT
    EXPECT_EQ(amount,3);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::total_event_regions(event_route)􏱺


􏷘+􏷗􏷒total distance􏷑
􏴅Annotated Route􏴆
􏷐the total distance of the route􏷏
􏶠calculates the total distance of the route by traversing all of the lanes􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to calculate distance over􏶿
􏶚m􏶛􏶾double􏶽􏶼total_distance􏶻􏲅0􏲆􏶺the total distance over the route􏶹
􏶴
    􏶲choosing range iteration over std::accumulate􏶱
    for (const auto & event : route.event_lane_sequence){
        total_distance += event.info.annotation.distance;
    }
􏶳
􏴯empty route has no distance􏴰
􏲝check that an empty route has no distance􏲞
􏲛an empty route should have a distance of zero􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({});
    auto event_route = create_event_route(r);
    
    //ACT
    auto distance = total_distance(event_route);
    
    //ASSERT
    EXPECT_EQ(distance,0);
􏴮
􏴯route has correct distance􏴰
􏲝check that a route has the correct distance􏲞
􏲛the route does not have the correct distance according to the lanes􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({10,10,10,10,10,10});
    auto event_route = create_event_route(r);
    
    //ACT
    auto distance = total_distance(event_route);
    
    //ASSERT
    EXPECT_EQ(distance,60);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::total_distance(event_route)􏱺


􏷘+􏷗􏷒current distance􏷑
􏴅Annotated Route􏴆
􏷐Our current distance along the route􏷏
􏶠calculates our total distance along the route
if we are updating our progress by lane indexes, then the best we can get is the previous lane lengths
in which case, we won't know where we are in the lane, and we will assume we are always 0 meters into our current lane􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to find the lane's distance on􏶿
􏶚m?􏶛􏶾d􏶽􏶼distance􏶻􏵜meters􏵝􏲅stdx::nullopt􏲆􏶺the lane index's starting distance􏶹
􏶴
    if (route.evaluation_range.current){
        distance_m = 􏵲lane index to distance􏵳route,*route.evaluation_range.current);
    }
􏶳
􏴯an empty route can not have a current distance􏴰
􏲝check that an empty route has no available current distance􏲞
􏲛an empty route should have no current distance􏲜
􏴭
    //ARRANGE
    event_annotated_route r;
    
    //ACT
    auto distance = current_distance(r);
    
    //ASSERT
    EXPECT_FALSE(distance);
􏴮
􏴯different locations along route􏴰
􏲝check the distance as we progress through the route􏲞
􏲛the expected distance does not match what our current index is􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({10,10,10,10,10,10});
    auto event_route = create_event_route(r);
    
    //ACT
    set_current_index_on_route(event_route,0);
    auto distance = current_distance(event_route);
    
    //ASSERT
    EXPECT_EQ(*distance,0);
    
    //ACT
    set_current_index_on_route(event_route,1);
    distance = current_distance(event_route);
    
    //ASSERT
    EXPECT_EQ(*distance,10);
    
    //ACT
    set_current_index_on_route(event_route,2);
    distance = current_distance(event_route);
    
    //ASSERT
    EXPECT_EQ(*distance,20);
    
    //ACT
    set_current_index_on_route(event_route,3);
    distance = current_distance(event_route);
    
    //ASSERT
    EXPECT_EQ(*distance,30);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::current_distance(event_route)􏱺

􏷘+􏷗􏷒distance to lane index􏷑
􏴅Annotated Route􏴆
􏷐convert a total accumulated distance along the route into the corresponding lane index􏷏
􏶠if we decide to traverse over the route using raw distance, we may also want to match that distance to a particular lane
if the distance provided goes beyond the distance of the route, then no lane index can be returned
if the route is empty, no lane index can be returned􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to find the lane on􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to to traverse the route with to find the corresponding lane􏶿
􏶚m?􏶛􏶾size􏶽􏶼lane index􏶻􏲅stdx::nullopt􏲆􏶺the lane index􏶹
􏶴
    double total_distance_m = 0;
    for (size_t i = 0; i < 􏵲number of lanes􏵳route); ++i){
        total_distance_m += 􏵲lane length􏵳route,i);
        if (total_distance_m > distance_m){
            return i;
        }
    }
􏶳
􏴯convert different distances to lane indexes􏴰
􏲝try different distances along route and confirm correct index􏲞
􏲛we did not get the expected distance to lane conversion􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({10,10,10,10,10,10});
    auto event_route = create_event_route(r);
    
    //ACT
    auto index = distance_to_lane_index(event_route,0);
    
    //ASSERT
    EXPECT_TRUE(index.has_value());
    EXPECT_EQ(*index,0);
    
    //ACT
    index = distance_to_lane_index(event_route,5);
    
    //ASSERT
    EXPECT_TRUE(index.has_value());
    EXPECT_EQ(*index,0);
    
    //ACT
    index = distance_to_lane_index(event_route,15);
    
    //ASSERT
    EXPECT_TRUE(index.has_value());
    EXPECT_EQ(*index,1);
    
    //ACT
    index = distance_to_lane_index(event_route,25);
    
    //ASSERT
    EXPECT_TRUE(index.has_value());
    EXPECT_EQ(*index,2);
    
    //ACT
    index = distance_to_lane_index(event_route,35);
    
    //ASSERT
    EXPECT_TRUE(index.has_value());
    EXPECT_EQ(*index,3);
􏴮
􏴯provided distance too long for any index􏴰
􏲝a distance longer than the entire route, cannot be converted into an index􏲞
􏲛we are somehow getting an index back when the provided distance does not correlate to any lane index􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_lane_distances({10,10,10,10,10,10});
    
    //ACT
    auto index = distance_to_lane_index(event_route,61);
    
    //ASSERT
    EXPECT_FALSE(index.has_value());
􏴮


􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::distance_to_lane_index(event_route,20*s.range(0))􏱺

􏷘+􏷗􏷒lane index to distance􏷑
􏴅Annotated Route􏴆
􏷐convert a lane index to the total accumulated distance of the route where the lane starts􏷏
􏶠if we decide to traverse over the route using lane indexes, we may also want to match that lane to our distance progress
if the lane index provided goes beyond the lane count of the route, the no distance is returned
if the route is empty, no distance is returned􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to find the lane's distance on􏶿
􏶜􏶝􏷆size􏷅􏷄lane_index􏷃􏵘􏵙􏷀the index of the lane to find its starting distance of􏶿
􏶚m?􏶛􏶾d􏶽􏶼distance􏶻􏵜meters􏵝􏲅stdx::nullopt􏲆􏶺the lane index's starting distance􏶹
􏶴
    double total_distance_m = 0;
    for (size_t i = 0; i < 􏵲number of lanes􏵳route); ++i){
        if (i == lane_index){
            return total_distance_m;
        }
        total_distance_m += 􏵲lane length􏵳route,i);
    }
􏶳
􏴯convert different lane indexes to distances􏴰
􏲝try different distances along route and confirm correct index􏲞
􏲛we did not get the expected distance to lane conversion􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_lane_distances({10,10,10,10,10,10});
    auto event_route = create_event_route(r);
    
    //ACT
    auto distance = lane_index_to_distance(event_route,0);
    
    //ASSERT
    EXPECT_TRUE(distance.has_value());
    EXPECT_EQ(*distance,0);
    
    //ACT
    distance = lane_index_to_distance(event_route,1);
    
    //ASSERT
    EXPECT_TRUE(distance.has_value());
    EXPECT_EQ(*distance,10);
    
    //ACT
    distance = lane_index_to_distance(event_route,2);
    
    //ASSERT
    EXPECT_TRUE(distance.has_value());
    EXPECT_EQ(*distance,20);
    
    //ACT
    distance = lane_index_to_distance(event_route,3);
    
    //ASSERT
    EXPECT_TRUE(distance.has_value());
    EXPECT_EQ(*distance,30);
􏴮
􏴯provided index too high for any distance􏴰
􏲝an index outside the route, cannot be converted into a distance􏲞
􏲛we are somehow getting a distance back when the provided index is not in the route􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_lane_distances({10,10,10,10,10,10});
    
    //ACT
    auto distance = lane_index_to_distance(event_route,6);
    
    //ASSERT
    EXPECT_FALSE(distance.has_value());
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::lane_index_to_distance(event_route,s.range(0))􏱺

􏷘+􏷗􏷒distance from start of lane􏷑
􏴅Annotated Route􏴆
􏷐convert a total accumulated distance along the route to a distance offset for the resulting lane􏷏
􏶠calculates the distance offset from the lane arrived to􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to find the lane on􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to to traverse the route with to find the corresponding lane and distance offset􏶿
􏶚m􏶛􏶾d􏶽􏶼distance offset􏶻􏲅0􏲆􏶺the distance offset from the lane􏶹
􏶴
    double total_distance_m = 0;
    for (size_t i = 0; i < 􏵲number of lanes􏵳route); ++i){
        total_distance_m += 􏵲lane length􏵳route,i);
        if (total_distance_m > distance_m){
            return 􏵲lane length􏵳route,i) - (total_distance_m - distance_m);
        }
    }
    
    // distance greater than entire route
    // we use the full length of the last lane
    if (!route.event_lane_sequence.empty()){
        distance_offset = 􏵲lane length􏵳route,route.event_lane_sequence.size()-1);
    }
􏶳
􏴯convert different distances to start of lane offset􏴰
􏲝try different distances and ensure they are the correct offset from the lane􏲞
􏲛we did not get the expected distance to lane conversion􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_lane_distances({10,10,10,10,10,10});
    
    //ACT
    auto offset = distance_from_start_of_lane(event_route,0);
    
    //ASSERT
    EXPECT_EQ(offset,0);
    
    //ACT
    offset = distance_from_start_of_lane(event_route,5);
    
    //ASSERT
    EXPECT_EQ(offset,5);
    
    //ACT
    offset = distance_from_start_of_lane(event_route,10);
    
    //ASSERT
    EXPECT_EQ(offset,0);
    
    //ACT
    offset = distance_from_start_of_lane(event_route,12);
    
    //ASSERT
    EXPECT_EQ(offset,2);
􏴮
􏴯distance greater than route 􏴰
􏲝a user's distance greater than the route is capped to the end of the route.  This means the offset to the last lane will be the length of that lane􏲞
􏲛the distance provided was either not capped to the end of the route, or the offset was calculated incorrectly􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_lane_distances({10,10,10,10,10,123});
    
    //ACT
    auto offset = distance_from_start_of_lane(event_route,500);
    
    //ASSERT
    EXPECT_EQ(offset,123);
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double> distances_m(s.range(0),20.0);
    auto event_route = create_event_route_from_lane_distances(distances_m);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::distance_from_start_of_lane(event_route,20*s.range(0))􏱺

􏷘+􏷗􏷒summary of state􏷑
􏴅String Representations􏴆
􏷐a brief but hopefully sufficient string representation of the annotated route's current state􏷏
􏶠for more detail on the route's state, you could dump all of its json, but we use this to provide the key information to aid in debugging􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get a summary of its state􏶿
􏶚m􏶛􏶾ascii_string􏶽􏶼summary􏶻􏲅􏲆􏶺the string representation summarizing the current state of the annotated route􏶹
􏶴
    summary += "route status: " + 􏵲route status as string􏵳route);
    summary += "\n";
    summary += "event range: " + 􏵲event range as string􏵳route);
    summary += "\n";
    summary += "annotated lanes: " + 􏵲evented lane indexes as string􏵳route);
    summary += "\n";
    summary += 􏵲evented lane guids as string􏵳route);
    auto broken_invariants = 􏵲broken invariants as string􏵳route);
    if (!broken_invariants.empty()){
        summary += "broken invariants:";
        summary += "\n";
        summary += broken_invariants;
    }
􏶳
􏴯summary of state on full route does not crash􏴰
􏲝We should be able to get the summary of a populated route without crashing􏲞
􏲛A runtime crash should not be possible. The string we get back should not be empty.􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4});
    auto event_route = create_event_route(r);
    
    //ACT
    auto results = summary_of_state(event_route);
    
    //ASSERT
    EXPECT_FALSE(results.empty());
􏴮
􏴯summary of state on empty route does not crash􏴰
􏲝We should be able to get the summary of an empty route without crashing􏲞
􏲛A runtime crash should not be possible. The string we get back should not be empty.􏲜
􏴭
    //ARRANGE
    route r;
    auto event_route = create_event_route(r);
    
    //ACT
    auto results = summary_of_state(event_route);
    
    //ASSERT
    EXPECT_FALSE(results.empty());
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double>                       distances(s.range(0), 10.0f);
    auto event_route = local_map::statik::create_event_route_from_lane_distances(distances);
􏱼
􏱹local_map::statik::summary_of_state(event_route)􏱺

􏷘+􏷗􏷒broken invariants as string􏷑
􏴅String Representations􏴆
􏷐a string where each line is a statement of a broken invariant􏷏
􏶠if there are no broken invariants, then the string is empty􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get broken invariants on􏶿
􏶚m􏶛􏶾ascii_string􏶽􏶼broken invariants􏶻􏲅􏲆􏶺the string representing broken invariants􏶹
􏶴
    // gather up all of the broken invariants
    // Although these broken invariants are handled safely in the regeneration framework,
    // they result in questionable awareness of SLMT's behavior
    auto messages = 􏵲failed invariants as messages􏵳route);
    
    //turn statements into single string
    for (auto const& it: messages){
        broken_invariants += it + '\n';
    }
􏶳
􏴯a new route does not have hysteresis􏴰
􏲝When we create a new route, it should not have any broken invariants except for lacking hysteresis􏲞
􏲛for some reason a new route does not have the same invariants􏲜
􏴭
    //ARRANGE
    auto r = create_event_route_from_submap_ids({1,2,3,4});
    
    //ACT
    auto results = broken_invariants_as_string(r);
    
    //ASSERT
    using ::testing::HasSubstr;
    EXPECT_THAT(results,HasSubstr("You don't have any route hysteresis."));
􏴮
􏴯an expected creation of SLMT event route􏴰
􏲝We create an SLA annotated event route for SLMT and we expect it to not have any invariants broken􏲞
􏲛for some reason the route has broken invariants􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({1,2,3,4,5,6});
    route_info.merge_point_index = 1; //why we have hysteresis
    route_info.route_changed = true;
    route_info.previous_lane_index = 2;
    route_info.current_lane_index = 1;
    int distance_m = 100;
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ACT
    auto results = broken_invariants_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(results,"");
􏴮
􏴯a single lane route is detected and reported􏴰
􏲝We create a single lane route and expect to see a broken invariant about it􏲞
􏲛We did not find the expected broken invariant􏲜
􏴭
    //ARRANGE
    //SLMT state
    slmt_route_information route_info;
    route r = create_route_from_submap_ids({123});
    route_info.merge_point_index = 0;
    route_info.route_changed = true;
    route_info.previous_lane_index = 0;
    route_info.current_lane_index = 0;
    int distance_m = 100;
    auto event_route = create_slmt_event_route(r, route_info,distance_m);
    
    //ACT
    auto results = broken_invariants_as_string(event_route);
    
    //ASSERT
    //disabled in implementation
    using ::testing::HasSubstr;
    EXPECT_THAT(results,Not(HasSubstr("The route has only 1 lane.")));
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double>                       distances(s.range(0), 10.0f);
    auto event_route = local_map::statik::create_event_route_from_lane_distances(distances);
􏱼
􏱹local_map::statik::broken_invariants_as_string(event_route)􏱺

􏷘-􏷗􏷒failed invariants as messages􏷑
􏴅Detail􏴆
􏷐get all the failed invariants as a collection of messages􏷏
􏶠check status of all invariants and convert broken invariants into messages􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get broken invariants on􏶿
􏶚m􏶛􏶾strings􏶽􏶼messages􏶻􏲅􏲆􏶺messages of broken invariants􏶹
􏶴
    // gather up all of the broken invariants
    // Although these broken invariants are handled safely in the regeneration framework,
    // they result in questionable awareness of SLMT's behavior
    auto checked_invariants = 􏵲check invariants􏵳route);
    
    // decide which invariants should NOT be reported to the user
    std::vector<event_annotated_route_invariants_rendering> render_settings;
    render_settings.emplace_back(true,checked_invariants.evaluation_range_consistent,"The evaluation range is inconsistent. You're telling me you went backwards.");
    render_settings.emplace_back(true,checked_invariants.evaluation_range_in_bounds,"The evaluation range is out of bounds from the actual route.");
    render_settings.emplace_back(true,checked_invariants.has_not_jumped_over_1_or_more_lanes,"You jumped over a lane.");
    render_settings.emplace_back(true,checked_invariants.has_route_hysteresis,"You don't have any route hysteresis.");
    render_settings.emplace_back(true,checked_invariants.exists_on_or_after_merge_point,"You claim to be on a route before the merge point.");
    render_settings.emplace_back(true,checked_invariants.merge_point_in_bounds,"The merge point exists outside the route.");
    render_settings.emplace_back(true,checked_invariants.route_has_lanes,"The route doesn't have any lanes.");
    render_settings.emplace_back(true,checked_invariants.all_lanes_have_size,"Some of the route lanes are of distance 0.");
    
    // "A one lane route is possible, but extremely unlikely outside
    // of a user error or navigator rerecord bug.
    // In rerecord we drop them." -- Bob Dean (@rdean)
    // Assuming 1 lane routes are still valid from vehicle command's perspective,
    // they result in not having hysteresis which is something we already check for.
    render_settings.emplace_back(false,checked_invariants.non_single_lane,"The route has only 1 lane.");
    
    // possibly show broken invariants
    for (auto const& it: render_settings){
        if (it.should_print){
            if (!it.condition_holds){
                messages.emplace_back(it.message);
            }
        }
    }
􏶳


􏷘+􏷗􏷒route status as string􏷑
􏴅String Representations􏴆
􏷐returns a string representing the conceptual state of the route􏷏
􏶠"new", "existing","current","invalid"􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get the status of􏶿
􏶚m􏶛􏶾ascii_string􏶽􏶼route status􏶻􏲅format_route_status_as_string(interpret_route_status(route))􏲆􏶺the status of the route􏶹
􏶴􏶳
􏴯a new route is called new􏴰
􏲝check that we have the right string representation for the route state􏲞
􏲛The route is probably not the state we expect it to be anymore. Or the state name has changed􏲜
􏴭
    //ARRANGE
    route r;
    auto event_route = create_event_route(r);
    
    //ACT
    auto name = route_status_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(name,"new");
􏴮
􏴯an existing route is called existing􏴰
􏲝check that we have the right string representation for the route state􏲞
􏲛The route is probably not the state we expect it to be anymore. Or the state name has changed􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_submap_ids({1,2,3,4,5});
    advance_forward_on_route(event_route,2);
    
    //ACT
    auto name = route_status_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(name,"existing");
􏴮
􏴯an expired route is called expired􏴰
􏲝check that we have the right string representation for the route state􏲞
􏲛The route is probably not the state we expect it to be anymore. Or the state name has changed􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_submap_ids({1,2,3,4,5});
    advance_forward_on_route(event_route,2);
    expire_route(event_route);
    
    //ACT
    auto name = route_status_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(name,"expired");
􏴮
􏴯an invalid route is called invalid􏴰
􏲝check that we have the right string representation for the route state􏲞
􏲛The route is probably not the state we expect it to be anymore. Or the state name has changed􏲜
􏴭
    //ARRANGE
    auto event_route = create_event_route_from_submap_ids({1,2,3,4,5});
    invalidate_route(event_route);
    
    //ACT
    auto name = route_status_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(name,"invalid");
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double>                       distances(s.range(0), 10.0f);
    auto event_route = local_map::statik::create_event_route_from_lane_distances(distances);
􏱼
􏱹local_map::statik::route_status_as_string(event_route)􏱺

􏷘+􏷗􏷒algorithm range as string􏷑
􏴅String Representations􏴆
􏷐returns a string representation of the algorithm range used when annotating the route􏷏
􏶠In all of these states we will display the unknown intervals with '?'
format: [#,#)􏶡
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route used to decide the algorithm range􏶿
􏶜􏶝􏷆algorithm_window􏷅􏷄range􏷃􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷀the chosen algorithm window to display􏶿􏷂algorithm_window()􏷁
􏶚m􏶛􏶾ascii_string􏶽􏶼algorithm range􏶻􏲅"["􏲆􏶺the string representation of the algorithm range􏶹
􏶴
    algorithm_range += std::to_string(􏵲algorithm start􏵳route,range));
    algorithm_range += ",";
    algorithm_range += std::to_string(􏵲algorithm end􏵳route,range));
    algorithm_range += ")";
􏶳
􏴯empty route has valid algorithm range􏴰
􏲝An empty route should have a valid algorithm range􏲞
􏲛The format of the range has changed from what we expect it to be on empty routes􏲜
􏴭
    //ARRANGE
    route r;
    
    //ACT
    auto range = algorithm_range_as_string(r);
    
    //ASSERT
    EXPECT_EQ(range,"[0,0)");
􏴮
􏴯single lane route correct default􏴰
􏲝The single lane route should have a valid algorithm range that spans the whole route􏲞
􏲛The format of the range has changed from what we expect it to be􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1});
    
    //ACT
    auto range = algorithm_range_as_string(r);
    
    //ASSERT
    EXPECT_EQ(range,"[0,1)");
􏴮
􏴯multi lane route correct default􏴰
􏲝The multi-lane route should have a valid algorithm range that spans the whole route􏲞
􏲛The format of the range has changed from what we expect it to be􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    
    //ACT
    auto range = algorithm_range_as_string(r);
    
    //ASSERT
    EXPECT_EQ(range,"[0,5)");
􏴮
􏴯multi lane route fix low start􏴰
􏲝If we create an algorithm route with a range that starts too early for the route, it will be fitted appropriately; this a convenience for safety􏲞
􏲛The route was not fitted, or the range is not what we expected􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    algorithm_window window;
    window.start = -1;
    
    //ACT
    auto range = algorithm_range_as_string(r);
    
    //ASSERT
    EXPECT_EQ(range,"[0,5)");
􏴮
􏴯multi lane route fix high end􏴰
􏲝If we create an algorithm route with a range that ends past the end of the route, it will be fitted appropriately; this a convenience for safety􏲞
􏲛The route was not fitted, or the range is not what we expected􏲜
􏴭
    //ARRANGE
    auto r = create_route_from_submap_ids({1,2,3,4,5});
    algorithm_window window;
    window.end = 6;
    
    //ACT
    auto range = algorithm_range_as_string(r);
    
    //ASSERT
    EXPECT_EQ(range,"[0,5)");
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double>                       distances(s.range(0), 10.0f);
    auto route = local_map::statik::create_route_from_lane_distances(distances);
􏱼
􏱹local_map::statik::algorithm_range_as_string(route)􏱺

􏷘+􏷗􏷒event range as string􏷑
􏴅String Representations􏴆
􏷐returns a string representation of the current event range to process for events over􏷏
􏶠new routes don't have a starting index in the interval
expired routes don't have an ending index in the interval
invalid routes don't have any interval to process
In all of these states we will display the unknown intervals with '?'
format: (#,#]􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get the event range from􏶿
􏶚m􏶛􏶾ascii_string􏶽􏶼event range􏶻􏲅􏲆􏶺the string representation of the event range􏶹
􏶴
    // representation of starting index
    std::string previous_index = "?";
    if (route.evaluation_range.previous)
    {
        previous_index = std::to_string(*(route.evaluation_range.previous));
    }

    // representation of ending index
    std::string current_index = "?";
    if (route.evaluation_range.current)
    {
        current_index = std::to_string(*(route.evaluation_range.current));
    }

    // representation of indexes as an interval
    event_range = "(" + previous_index + "," + current_index + "]";
􏶳
􏴯new route has expected event range􏴰
􏲝We know what the event range of a new route should look like.  Check for it.􏲞
􏲛The format of the range has changed, or initial window configuration no longer holds􏲜
􏴭
    //ARRANGE
    route r;
    auto event_route = create_event_route(r);
    
    //ACT
    auto range = event_range_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(range,"(?,0]");
􏴮
􏴯new to expired route has expected event range􏴰
􏲝We know what the event range of an expired route should look like.  Check for it.􏲞
􏲛The format of the range has changed, or window configuration no longer transitions the same way􏲜
􏴭
    //ARRANGE
    route r;
    auto event_route = create_event_route(r);
    
    //ACT
    expire_route(event_route);
    auto range = event_range_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(range,"(0,?]");
􏴮
􏴯invalidated routes have an expected event range􏴰
􏲝We know what the event range of an invalidated route should look like.  Check for it.􏲞
􏲛The format of the range has changed, or window configuration no longer transitions the same way􏲜
􏴭
    //ARRANGE
    route r;
    auto event_route = create_event_route(r);
    
    //ACT
    invalidate_route(event_route);
    auto range = event_range_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(range,"(?,?]");
􏴮
􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double>                       distances(s.range(0), 10.0f);
    auto event_route = local_map::statik::create_event_route_from_lane_distances(distances);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::event_range_as_string(event_route)􏱺

􏷘+􏷗􏷒evented lane indexes as string􏷑
􏴅String Representations􏴆
􏷐returns a string representation of the current lane indexes with events􏷏
􏶠format: [#,#,#,#]􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get event lane indexes from􏶿
􏶚m􏶛􏶾ascii_string􏶽􏶼event lane indexes􏶻􏲅"["􏲆􏶺the string representation of the current event lane indexes􏶹
􏶴
    auto indexes = 􏵲all lanes with annotations􏵳route);
    bool first = true;
    for (const auto & it: indexes){
        if (first){
            first = false;
        }else{
            event_lane_indexes += ", ";
        }
        
        event_lane_indexes += std::to_string(it);
    }
    event_lane_indexes += "]";
􏶳
􏴯empty indexes when given empty route􏴰
􏲝We should be able to get the string representation of selected lanes when no lanes are selected􏲞
􏲛A runtime crash should not be possible. The string we get back should be and empty list􏲜
􏴭
    //ARRANGE
    route r;
    auto event_route = create_event_route(r);
    
    //ACT
    auto results = evented_lane_indexes_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(results,"[]");
􏴮
􏴯single index􏴰
􏲝test that we can see a single index􏲞
􏲛the single index was not found􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,2,3,4,5});
    auto indexes = select_first_lane(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    auto results = evented_lane_indexes_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(results,"[0]");
􏴮
􏴯all indexes􏴰
􏲝test that we can see all index􏲞
􏲛not all indexes were found􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({1,2,3,4,5});
    auto indexes = select_all_lanes(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    auto results = evented_lane_indexes_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(results,"[0, 1, 2, 3, 4]");
􏴮


􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double>                       distances(s.range(0), 10.0f);
    auto event_route = local_map::statik::create_event_route_from_lane_distances(distances);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::evented_lane_indexes_as_string(event_route)􏱺

􏷘+􏷗􏷒evented lane guids as string􏷑
􏴅String Representations􏴆
􏷐returns a string representation of the current lane guids with events􏷏
􏶠format: guids separated by newlines􏶡
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get event lane guids from􏶿
􏶚m􏶛􏶾ascii_string􏶽􏶼event lane guids􏶻􏲅􏲆􏶺the string representation of the current event lane guids􏶹
􏶴
    auto guids = 􏵲all lane guids with annotations􏵳route);
    for (const auto & it: guids){
        event_lane_guids += it.str() + "\n";
    }
􏶳
􏴯empty string when given empty route􏴰
􏲝We should be able to get an empty string representation of selected lane guids, when no lanes are selected􏲞
􏲛A runtime crash should not be possible. The string we get back should be empty􏲜
􏴭
    //ARRANGE
    route r;
    auto event_route = create_event_route(r);
    
    //ACT
    auto results = evented_lane_guids_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(results,"");
􏴮
􏴯single guid􏴰
􏲝test that we can see a single index􏲞
􏲛the single index was not found􏲜
􏴭
    //ARRANGE
    route r = create_route_from_submap_ids({6,7,8,9});
    auto indexes = select_first_lane(r);
    auto event_route = create_event_route(r);
    set_regeneration_events(event_route,indexes,"test");
    
    //ACT
    auto results = evented_lane_guids_as_string(event_route);
    
    //ASSERT
    EXPECT_EQ(results,"{00000000-0000-0000-0000-000000000000}\n");
􏴮

􏱿regular growth􏲀􏱽􏱾
􏱷length of route􏱸􏱵8􏱶􏱳8 << 11􏱴􏱱2􏱲
􏱻
    s.SetComplexityN(s.range(0));
    const std::vector<double>                       distances(s.range(0), 10.0f);
    auto event_route = local_map::statik::create_event_route_from_lane_distances(distances);
    
    set_previous_index_on_route(event_route,0);
    set_current_index_on_route(event_route,s.range(0));
􏱼
􏱹local_map::statik::evented_lane_guids_as_string(event_route)􏱺


􏷘-􏷗􏷒first index to process􏷑
􏷐gets the first index to process over the route􏷏
􏶠determined through the event view of the route
this may or may not check for bounds validity depending on how we configure it􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏲅first_index_to_process_safe(route)􏲆􏶺the lane index􏶹
􏶴􏶳

􏷘-􏷗􏷒last index to process􏷑
􏷐gets the last index to process over the route􏷏
􏶠determined through the event view of the route
this may or may not check for bounds validity depending on how we configure it􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏲅last_index_to_process_safe(route)􏲆􏶺the lane index􏶹
􏶴􏶳


􏷘-􏷗􏷒first index to process unsafe􏷑
􏷐gets the first index to process over the route􏷏
􏶠determined through the event view of the route
the event view's index is not checked for bounds validity􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏲅0􏲆􏶺the lane index􏶹
􏶴
    􏶲if we don't have a previous index we start processing at the beginning􏶱
    􏶲if we do have a previous index we leave off processing the remaining lanes􏶱
    if (route.evaluation_range.previous){
        lane_index = *route.evaluation_range.previous + 1;
    }
􏶳
􏷘-􏷗􏷒first index to process safe􏷑
􏷐gets the first index to process over the route􏷏
􏶠determined through the event view of the route
the index is fitted for bounds validity􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏲅fitted_index_for_iteration(route,first_index_to_process_unsafe(route))􏲆􏶺the lane index􏶹
􏶴􏶳
􏷘-􏷗􏷒last index to process unsafe􏷑
􏷐gets the last index to process over the route􏷏
􏶠determined through the event view of the route
the event view's index is not checked for bounds validity􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏲅last_lane_index(route)􏲆􏶺the lane index􏶹
􏶴
    􏶲if we don't have a current index, we process to the end of the route􏶱
    􏶲if we do have have a current index, we use that􏶱
    if (route.evaluation_range.current){
        lane_index = *route.evaluation_range.current;
    }
􏶳
􏷘-􏷗􏷒last index to process safe􏷑
􏷐gets the last index to process over the route􏷏
􏶠determined through the event view of the route
the index is fitted for bounds validity􏶡
􏴅Detail􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀event annotated route􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏲅fitted_index_for_iteration(route,last_index_to_process_unsafe(route))􏲆􏶺the lane index􏶹
􏶴􏶳

􏷘-􏷗􏷒last lane index􏷑
􏷐the index of the last lane􏷏
􏶠Assumes the route is not empty􏶡
􏴅Detail􏴆
􏵪!route_is_empty()􏵫
􏵨the route is not empty􏵩
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to get the last lane index from􏶿
􏶚m􏶛􏶾size􏶽􏶼lane index􏶻􏲅0􏲆􏶺the index of the last lane􏶹
􏶴
    if (􏵲has lanes􏵳route)){
        lane_index = route.event_lane_sequence.size()-1;
    }
􏶳

􏷘-􏷗􏷒insert previous􏷑
􏷐store the previous index􏷏
􏶠Assumes the previous index is valid􏶡
􏴅Detail􏴆
􏵪index != 0􏵫
􏵨the previous index exists􏵩
􏶜mr􏶝􏷆unordered_indexes􏷅􏷄indexes􏷃􏷀indexes􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the next we should store the previous of􏶿
􏶴
    if (index != 0){
        indexes.insert(index-1);
    }
􏶳

􏷘-􏷗􏷒insert next􏷑
􏷐store the next index􏷏
􏶠Assumes the next index is valid􏶡
􏴅Detail􏴆
􏵪index+1 is a valid index for the route􏵫
􏵨index+1 is a valid index for the route􏵩
􏶜mr􏶝􏷆unordered_indexes􏷅􏷄indexes􏷃􏷀indexes􏶿
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to check for valid indexes with􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the index we should store the next of (if possible)􏶿
􏶴
    if (index+1 < 􏵲number of lanes􏵳route)){
        indexes.insert(index+1);
    }
􏶳

􏷘-􏷗􏷒no lane longer than distance􏷑
􏷐checks to see if any individual lane is longer then the distance provided􏷏
􏶠True if any lane is longer; false otherwise.􏶡
􏴅Detail􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶜􏶝􏷆d􏷅􏷄distance􏷃􏵘meters􏵙􏷀the distance to check against􏶿
􏶚m􏶛􏶾bool􏶽􏶼no lane longer􏶻􏶺whether any lane is longer than the distance􏶹
􏶴
    
    􏶲simplify predicate􏶱
    no_lane_longer = std::none_of(route.annotation_sequence.begin(),route.annotation_sequence.end(),[&](const route_planning::lane_neighbor_annotation & annotation){
        return annotation.distance > distance_m;
    });
􏶳

􏷘-􏷗􏷒is positive􏷑
􏷐checks whether the number is positive􏷏
􏶠0 is not positive􏶡
􏴅Detail􏴆
􏶜􏶝􏷆d􏷅􏷄num􏷃􏷀the number to check􏶿
􏶚m􏶛􏶾bool􏶽􏶼is positive􏶻􏲅num > 0􏲆􏶺whether the number is positive􏶹
􏶴􏶳

􏷘-􏷗􏷒has lanes􏷑
􏷐checks whether the route has lanes􏷏
􏶠True if there are any lanes, False if there is not􏶡
􏴅Shared Interface􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶚m􏶛􏶾bool􏶽􏶼has lanes􏶻􏲅!route.lane_sequence.empty()􏲆􏶺whether the route has lanes􏶹
􏶴􏶳

􏷘-􏷗􏷒is single lane route􏷑
􏷐checks whether the route is a single lane route􏷏
􏶠True if the route has a single lane; false otherwise􏶡
􏴅Shared Interface􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze lanes on􏶿
􏶚m􏶛􏶾bool􏶽􏶼is single lane route􏶻􏲅route.lane_sequence.size() == 1􏲆􏶺whether the route is a single lane􏶹
􏶴􏶳

􏷘-􏷗􏷒lane length􏷑
􏷐get the length of a particular indexed lane􏷏
􏴅Shared Interface􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the lane index􏶿
􏶚m􏶛􏶾d􏶽􏶼length􏶻􏵜meters􏵝􏲅route.annotation_sequence[index].distance􏲆􏶺the length of the lane􏶹
􏶴􏶳

􏷘-􏷗􏷒number of lanes􏷑
􏷐the number of lanes in the route􏷏
􏴅Shared Interface􏴆
􏶜􏶝􏷆route􏷅􏲧local_map/static/route/local_map_route􏲨􏲥local_map/static/route/local_map_route_lib􏲦􏷄route􏷃􏷀the route in which to count lanes􏶿
􏶚m􏶛􏶾size􏶽􏶼number of lanes􏶻􏲅route.lane_sequence.size()􏲆􏶺the number of lanes in the route􏶹
􏶴􏶳



􏷘-􏷗􏷒has lanes􏷑
􏷐checks whether the route has lanes􏷏
􏶠True if there are any lanes, False if there is not􏶡
􏴅Shared Interface􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶚m􏶛􏶾bool􏶽􏶼has lanes􏶻􏲅!route.event_lane_sequence.empty()􏲆􏶺whether the route has lanes􏶹
􏶴􏶳

􏷘-􏷗􏷒is single lane route􏷑
􏷐checks whether the route is a single lane route􏷏
􏶠True if the route has a single lane; false otherwise􏶡
􏴅Shared Interface􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze lanes on􏶿
􏶚m􏶛􏶾bool􏶽􏶼is single lane route􏶻􏲅route.event_lane_sequence.size() == 1􏲆􏶺whether the route is a single lane􏶹
􏶴􏶳

􏷘-􏷗􏷒lane length􏷑
􏷐get the length of a particular indexed lane􏷏
􏴅Shared Interface􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route to analyze lane lengths􏶿
􏶜􏶝􏷆size􏷅􏷄index􏷃􏷀the lane index􏶿
􏶚m􏶛􏶾d􏶽􏶼length􏶻􏵜meters􏵝􏲅route.event_lane_sequence[index].info.annotation.distance􏲆􏶺the length of the lane􏶹
􏶴􏶳

􏷘-􏷗􏷒number of lanes􏷑
􏷐the number of lanes in the route􏷏
􏴅Shared Interface􏴆
􏶜􏶝􏷆event_annotated_route􏷅􏲧local_map/libs/regeneration/event_annotations􏲨􏲥local_map/libs/regeneration/local_map_regeneration_event_annotations􏲦􏷄route􏷃􏷀the route in which to count lanes􏶿
􏶚m􏶛􏶾size􏶽􏶼number of lanes􏶻􏲅route.event_lane_sequence.size()􏲆􏶺the number of lanes in the route􏶹
􏶴􏶳