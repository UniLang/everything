class
❪"code/utilities/graphics/x11/data/main_x11_state"❫
❪GL/gl.h❫
❪GL/glx.h❫
⚯
⚞⚟

//This is basically done for the case where you need to opengl to draw to an x11 window
//such as when you are making a screensaver for xscreensaver
◀public: static▶ void ☀Bind(Main_X11_State & x11)❰

    Check_GLX_With_X11_Is_Possible(x11);
    

    GLXFBConfig *fbc = Create_Framebuffer_Config(x11);
    
    // Get a visual
    //maybe we could use glXChooseVisual instead?
    XVisualInfo *vi = glXGetVisualFromFBConfig(x11.d, fbc[0]);
    
    
    //So we could get graphic context.
    typedef GLXContext (*glXCreateContextAttribsARBProc)(Display *, GLXFBConfig, GLXContext, Bool, const int *);
    glXCreateContextAttribsARBProc glXCreateContextAttribsARB = nullptr;
    glXCreateContextAttribsARB =
            (glXCreateContextAttribsARBProc)
                    glXGetProcAddress((const GLubyte *) "glXCreateContextAttribsARB");

    #define GLX_CONTEXT_MAJOR_VERSION_ARB       0x2091
    #define GLX_CONTEXT_MINOR_VERSION_ARB       0x2092
    int context_attribs[] =
            {
                    GLX_CONTEXT_MAJOR_VERSION_ARB, 3,
                    GLX_CONTEXT_MINOR_VERSION_ARB, 3,
                    None
            };

    GLXContext ctx = glXCreateContextAttribsARB(x11.d, fbc[0], nullptr, true, context_attribs);
    // Sync to ensure any errors generated are processed.
    XSync(x11.d, false);
    glXMakeCurrent(x11.d, x11.root, ctx);
    // Be sure to free the FBConfig list allocated by glXChooseFBConfig()
    XFree(fbc);
    
    // Get the window attributes
    //Set viewport to parent window's width/height
    XWindowAttributes wa;
    XGetWindowAttributes(x11.d, x11.root, &wa);
    glViewport(0, 0, wa.width, wa.height);
❱

◀private: static▶ void ☀Check_GLX_With_X11_Is_Possible(Main_X11_State const& x11)❰

    // Make sure OpenGL's GLX extension is supported.  The
    // glXQueryExtension also returns the GLX extension's error base and event
    // base.  For almost all OpenGL programs, this information is irrelevant;
    // hence the use of dummy.
    int dummy = 0;
    if(!glXQueryExtension(x11.d, &dummy, &dummy)){
        std::cerr << "X server has no OpenGL GLX extension" << std::endl;
        exit(-1);
    }
❱

◀private: static▶ GLXFBConfig* ☀Create_Framebuffer_Config(Main_X11_State const& x11)❰

    // Get a matching FB config
    static int visual_attribs[] =
            {
                    GLX_X_RENDERABLE, true,
                    GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
                    GLX_RENDER_TYPE, GLX_RGBA_BIT,
                    GLX_X_VISUAL_TYPE, GLX_TRUE_COLOR,
                    GLX_RED_SIZE, 8,
                    GLX_GREEN_SIZE, 8,
                    GLX_BLUE_SIZE, 8,
                    GLX_ALPHA_SIZE, 8,
                    GLX_DEPTH_SIZE, 24,
                    GLX_STENCIL_SIZE, 8,
                    GLX_DOUBLEBUFFER, true,
                    //GLX_SAMPLE_BUFFERS  , 1,
                    //GLX_SAMPLES         , 4,
                    None
            };

    //Get framebuffer config
    int fbcount;
    GLXFBConfig *fbc = glXChooseFBConfig(x11.d, DefaultScreen(x11.d), visual_attribs, &fbcount);
    return fbc;
❱

◀private: static▶ XVisualInfo* ☀Create_Visual(Main_X11_State const& x11)❰

    int  sngBuf[] = {    GLX_RGBA,
                    GLX_RED_SIZE, 1,
                    GLX_GREEN_SIZE, 1,
                    GLX_BLUE_SIZE, 1,
                    GLX_DEPTH_SIZE, 12,
                    None };

    int  dblBuf[] = {    GLX_RGBA,
                    GLX_RED_SIZE, 1,
                    GLX_GREEN_SIZE, 1,
                    GLX_BLUE_SIZE, 1,
                    GLX_DEPTH_SIZE, 12,
                    GLX_DOUBLEBUFFER,
                    None };
   
  XVisualInfo* vi;
  if(!(vi = glXChooseVisual(x11.d, DefaultScreen(x11.d), dblBuf))) {
    if(!(vi = glXChooseVisual(x11.d, DefaultScreen(x11.d), sngBuf))){
        std::cerr << "no RGB visual with depth buffer" << std::endl;
        exit(-1);
    }
  }
  return vi;
  
❱

