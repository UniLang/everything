class
❪string❫
❪unordered_map❫
❪utility❫
❪cstdlib❫
❪"code/utilities/data_structures/graphics/objects/buildable_faced_tree/data/buildable_face_tree"❫
❪"code/utilities/data_structures/tree/generic/child_lookup_map"❫
❪"code/utilities/code/style_theme/style_lookup_map"❫
❪"code/utilities/code/style_theme/style_theme"❫
⚯
❪"code/utilities/data_structures/graphics/objects/faced_tree/tree_label_click_finder"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_label/premade/buttoned_faced_label_premades"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/button_face_tree_full_path_name"❫
❪"code/utilities/data_structures/tree/generic/child_lookup_map_find"❫
❪"code/utilities/types/strings/transformers/removing/lib"❫
❪"code/utilities/data_structures/graphics/objects/buildable_faced_tree/buildable_face_tree_action_doer"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/data_structures/graphics/objects/buildable_schema_faced_tree/style_theme_applier"❫
⚞⚟

◀public: static▶ void ☀Handle_Menu_Click(Buildable_Face_Tree_State & tree, Child_Lookup_Map const& lookup, Style_Lookup_Map const& style_lookup)❰

    auto found = Tree_Label_Click_Finder::Find_Clicked_Label(tree.menu.menu);
    if (found != tree.menu.menu.nodes.end()){
        Handle_Menu_Action(tree,lookup,style_lookup,found->state.faces[0].label.message);
    }
❱


◀private: static▶ void ☀Handle_Menu_Action(Buildable_Face_Tree_State & tree, Child_Lookup_Map const& lookup, Style_Lookup_Map const& style_lookup, std::string message)❰
    
    auto symbol = Remove_And_Get_First_Char(message);
    
    if (symbol == "+"){
        Add_Child_Node(tree,lookup,style_lookup,message);
    }
    if (symbol == "~"){
        Replace_Selected_Node(tree,lookup,style_lookup,message);
    }
    if (symbol == ":"){
        Handle_Generic_Tree_Actions(tree,lookup,message);
    }

❱

◀private: static▶ void ☀Handle_Generic_Tree_Actions(Buildable_Face_Tree_State & tree, Child_Lookup_Map const& lookup, std::string const& message)❰
    if (message == "delete"){
        Buildable_Face_Tree_Action_Doer::Do_Label_Action(tree,Buildable_Label_Action::DELETE);
    }
    else if (message == "duplicate"){
        Buildable_Face_Tree_Action_Doer::Do_Label_Action(tree,Buildable_Label_Action::DUPLICATE);
    }
❱
◀private: static▶ void ☀Add_Child_Node(Buildable_Face_Tree_State & tree, Child_Lookup_Map const& lookup, Style_Lookup_Map const& style_lookup, std::string const& message)❰

    auto x = Create_Styled_Unilang_Node_Via_Parent(tree,tree.selected_node,lookup,style_lookup,message);
    tree.structure.nodes.append_child(tree.selected_node,x);
❱
◀private: static▶ void ☀Replace_Selected_Node(Buildable_Face_Tree_State & tree, Child_Lookup_Map const& lookup, Style_Lookup_Map const& style_lookup, std::string const& message)❰

    //I think this will always be valid because you won't have the choice to replace on a non-parent node.
    //so this should not through a navigation error.
    auto parent = tree.structure.nodes.parent(tree.selected_node);
    
    
    auto x = Create_Styled_Unilang_Node_Via_Parent(tree,parent,lookup,style_lookup, message);
    *tree.selected_node = x;
❱

◀private: static▶ Buttoned_Faced_Label ☀Create_Styled_Unilang_Node_Via_Parent(Buildable_Face_Tree_State & tree, ::tree<Buttoned_Faced_Label>::pre_order_iterator parent, Child_Lookup_Map const& lookup, Style_Lookup_Map const& style_lookup, std::string const& message)❰
    
    //decide how many faces and what they are going to say
    Buttoned_Faced_Label new_label;
    if (Is_Chosen_Child_A_Leaf(tree.structure,lookup,parent,message)){
        new_label = Buttoned_Faced_Label_Premades::Opened_Unilang_Leaf_Node(message);
    }
    else {
        new_label = Buttoned_Faced_Label_Premades::Opened_Unilang_NonLeaf_Node(message);
    }
    
    
    //change color and style based on a customizable theme
    auto full_name = With_Child_Name(tree.structure,parent,message);
    Style_Theme_Applier::Apply_Theme(new_label,style_lookup,full_name);
    
    
    return new_label;
❱



◀private: static▶ bool ☀Is_Chosen_Child_A_Leaf(Button_Face_Tree const& structure, Child_Lookup_Map const& lookup, ::tree<Buttoned_Faced_Label>::pre_order_iterator it, std::string const& child_name)❰
    auto full_name = With_Child_Name(structure,it,child_name);
    
    auto strs = Child_Lookup_Map_Find::Get_Children(lookup,full_name);
    return strs.empty();
❱


◀private: static▶ std::string ☀With_Child_Name(Button_Face_Tree const& structure, ::tree<Buttoned_Faced_Label>::pre_order_iterator it, std::string const& child_name)❰
    auto full_name = Button_Face_Tree_Full_Path_Name::Get(structure,it);
    full_name += child_name + "/";
    return full_name;
❱