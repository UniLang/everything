class
❪string❫
❪unordered_map❫
❪utility❫
❪cstdlib❫
❪vector❫
❪"code/utilities/fonts/bdf/settings/character_segment"❫
❪"code/utilities/data_structures/graphics/objects/label/data/label_settings"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_label/data/positioned_buttoned_faced_label"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/positioned_button_face_tree"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/button_face_tree"❫
❪"code/utilities/data_structures/graphics/objects/label/label_drawer"❫
❪"code/utilities/data_structures/graphics/objects/frame_elements"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/data_structures/graphics/objects/faced_label/faced_label_drawer"❫
❪"code/utilities/data_structures/graphics/objects/faced_label/faced_label_eventer"❫
❪"code/utilities/peripheral/mouse/state/mouse_state"❫
❪"code/utilities/fonts/bdf/character_maps/character_maps"❫
❪"code/utilities/data_structures/counters/unique_max_counter/unique_max_counter"❫
❪"code/utilities/code/references/reference_lookup_map"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/button_face_tree_range"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/positioned_button_tree_iterator"❫
⚯
❪"code/utilities/data_structures/graphics/objects/mouse/events/mouse_events_checker"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/data_structures/graphics/bitmap/premade/vertical_line"❫
❪"code/utilities/data_structures/graphics/bitmap/premade/horizontal_line"❫
❪"code/utilities/data_structures/graphics/bitmap/premade/l_line"❫
❪"code/utilities/data_structures/graphics/bitmap/premade/right_arrow"❫
❪"code/utilities/data_structures/graphics/bitmap/premade/left_arrow"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_label/buttoned_faced_label_is_active"❫
❪"code/utilities/data_structures/graphics/objects/faced_label/faced_label_is_active"❫
❪"code/utilities/data_structures/graphics/objects/faced_label/faced_label_set_active"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/button_tree_global_navigation"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_label/buttoned_faced_label_drawer"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/for_each_noncollapsed"❫
❪"code/utilities/data_structures/graphics/objects/buttoned_faced_tree/button_face_tree_full_path_name"❫
❪"code/utilities/math/math"❫
⚞⚟

◀public: static▶ Frame_Elements ☀Draw(Character_Maps const& font_chars, Positioned_Button_Face_Tree & tree, Pc_Input_State const& pc_input, Reference_Lookup_Map const& ref_map)❰
    
    Frame_Elements elements;
    
    //create traversal range
    Button_Face_Tree_Range range = Full_Range(tree);
    
    Button_Tree_Global_Navigation::Handle_User_Events     (font_chars,elements,pc_input,tree.pos,tree.nodes,tree.nodes.begin(),tree.nodes.end());
    Draw_Tree(font_chars,elements,pc_input,tree.pos,tree.nodes,range,ref_map);
    return elements;
❱
◀public: static▶ Frame_Elements ☀Draw(Character_Maps const& font_chars, Button_Face_Tree & tree, Position const& pos, Pc_Input_State const& pc_input, Reference_Lookup_Map const& ref_map)❰
    
    Frame_Elements elements;
    
    //create traversal range
    Button_Face_Tree_Range range = Full_Range(tree);
    
    Button_Tree_Global_Navigation::Handle_User_Events     (font_chars,elements,pc_input,pos,tree.nodes,tree.nodes.begin(),tree.nodes.end());
    Draw_Tree(font_chars,elements,pc_input,pos,tree.nodes,range,ref_map);
    return elements;
❱



//get full ranges
◀private: static▶ Button_Face_Tree_Range ☀Full_Range(Button_Face_Tree & tree)❰
    Button_Face_Tree_Range range;
    range.begin = tree.nodes.begin();
    range.end = tree.nodes.end();
    return range;
❱
◀private: static▶ Button_Face_Tree_Range ☀Full_Range(Positioned_Button_Face_Tree & tree)❰
    Button_Face_Tree_Range range;
    range.begin = tree.nodes.begin();
    range.end = tree.nodes.end();
    return range;
❱


◀private: static▶ void ☀Draw_Tree(Character_Maps const& font_chars, Frame_Elements & elements, Pc_Input_State const& pc_input, Position const& pos, const tree<Buttoned_Faced_Label>& tr, Button_Face_Tree_Range const& range, Reference_Lookup_Map const& ref_map)❰
    
    
    elements.types += Build_Branches_And_Button_Labels(font_chars,pc_input,pos,tr,range).types;
    elements.types += Build_Generic_Schema_References(font_chars,pc_input,pos,tr,range,ref_map).types;
    
❱

◀private: static▶ Frame_Elements  ☀Build_Generic_Schema_References(Character_Maps const& font_chars, Pc_Input_State const& pc_input, Position const& pos, const tree<Buttoned_Faced_Label>& tr, Button_Face_Tree_Range const& range, Reference_Lookup_Map const& ref_map)❰
    
    //iterate the tree to get all path locations.
    //this way we can draw the references by looking up the path instead of re-traversing the tree
    auto path_positions = Get_Path_Positions(font_chars,pc_input,pos,tr,range);
    
    //use the reference map and path positions to get the pos-to-pos positioning
    auto connections = Get_Position_Connections(path_positions,ref_map);
    
    //draw references
    Frame_Elements x;
    
    for (auto const& it: connections){
        
        //calculate how much the connection bar should stick out to the right of the tree
        auto depth_out = Calculate_Out_Depth(tr,it);
        
        auto from_horiz_start = it.first.pos;
        auto to_horiz_start = it.second.pos;
        
        //adjust to middle of label
        from_horiz_start.y += 7;
        to_horiz_start.y += 7;
        
        //adjust to end of label
        from_horiz_start.x += Faced_Label_Drawer::Get_Dimensions(it.first.it->label).x;
        to_horiz_start.x += Faced_Label_Drawer::Get_Dimensions(it.second.it->label).x;
        
        //calculate the two horizontal bars of the connection
        auto from_horizontal = Horizontal_Line::Create_Positioned(from_horiz_start,Math::difference(from_horiz_start.x,depth_out));
        auto to_horizontal = Horizontal_Line::Create_Positioned(to_horiz_start,Math::difference(to_horiz_start.x,depth_out));
        
        
        //calculate vertical line
        auto vertical_pos = from_horiz_start;
        vertical_pos.x += Math::difference(vertical_pos.x,depth_out);
        vertical_pos.y = std::min(from_horizontal.pos.y,to_horizontal.pos.y);
        
        auto vertical_height = Math::difference(from_horizontal.pos.y,to_horizontal.pos.y);
        
        auto vertical = Vertical_Line::Create_Positioned(vertical_pos,vertical_height);
        
        auto arrow = Left_Arrow::Create_Positioned(to_horiz_start,4);
        arrow.pos.y -=2;
        
        x.types.emplace_back(from_horizontal);
        x.types.emplace_back(to_horizontal);
        x.types.emplace_back(vertical);
        
        x.types.emplace_back(arrow);
    }
    
    return x;
❱

◀private: static▶ int ☀Calculate_Out_Depth(tree<Buttoned_Faced_Label> const& tr, std::pair<Positioned_Button_Tree_Iterator,Positioned_Button_Tree_Iterator> const& connection)❰

    //decide the correct way to loop through a subset of the tree
    auto begin = connection.first;
    auto end = connection.second;
    Swap_If_Needed(tr,begin,end);
    
    
    auto start_pos = begin.pos;
    auto current_pos = begin.pos;
    
    auto out_depth = begin.pos.x;
    For_Each_Noncollapsed::Iterate(tr,begin.it,end.it,[&](tree<Buttoned_Faced_Label>::pre_order_iterator it, int depth){
        
        //adjust position
        Adjust_Positions_For_Next_Cell(it->label,start_pos,current_pos,depth);
        
        out_depth = std::max(out_depth,Faced_Label_Drawer::Get_Dimensions(it->label).x + current_pos.x);
        
        return Should_Break::NO;
    });
    
    //buffer space
    out_depth += 5;
    return out_depth;
❱

◀private: static▶ void ☀Swap_If_Needed(tree<Buttoned_Faced_Label> const& tr, Positioned_Button_Tree_Iterator & a, Positioned_Button_Tree_Iterator & b)❰

    //damn, I can't compare the iterators directly.  How do I know which one comes first?
    //i'll inefficiently iterate the tree and see which one is first.
    //then swap if necessary

    For_Each_Noncollapsed::Iterate(tr,tr.begin(),tr.end(),[&](tree<Buttoned_Faced_Label>::pre_order_iterator it, int depth){
        //correct order
        if (a.it == it){
            return Should_Break::YES;
        }
        
        //backwards. needs fixed
        if (b.it == it){
            std::swap(a,b);
            return Should_Break::YES;
        }
        
        return Should_Break::NO;
    });
❱


◀private: static▶ std::vector<std::pair<Positioned_Button_Tree_Iterator,Positioned_Button_Tree_Iterator>> ☀Get_Position_Connections(std::unordered_map<std::string,Positioned_Button_Tree_Iterator> const& path_positions, Reference_Lookup_Map const& ref_map)❰

    std::vector<std::pair<Positioned_Button_Tree_Iterator,Positioned_Button_Tree_Iterator>> result;
    for (auto const& it: path_positions){
        auto found = ref_map.map.find(it.first);
        
        //we need to create a reference
        if (found != ref_map.map.end()){
            
            
            auto FROM = it.second;
            auto fk_found = ref_map.map.find(found->first);
            if (fk_found != ref_map.map.end()){
                
                auto found_to_pos = path_positions.find(fk_found->second);
                auto TO = found_to_pos->second;
                
                result.emplace_back(FROM,TO);
            }
            
        }
    }
    
    return result;
    
❱
◀private: static▶ std::unordered_map<std::string,Positioned_Button_Tree_Iterator> ☀Get_Path_Positions(Character_Maps const& font_chars, Pc_Input_State const& pc_input, Position const& pos, const tree<Buttoned_Faced_Label>& tr, Button_Face_Tree_Range const& range)❰
    

    std::unordered_map<std::string,Positioned_Button_Tree_Iterator> path_positions;
    
    
    auto start_pos = pos;
    auto current_pos = pos;
    
    For_Each_Noncollapsed::Iterate(tr,range.begin,range.end,[&](tree<Buttoned_Faced_Label>::pre_order_iterator it, int depth){
        
        //adjust position
        Adjust_Positions_For_Next_Cell(it->label,start_pos,current_pos,depth);
        
        //add position for label path
        std::pair<std::string,Positioned_Button_Tree_Iterator> result;
        result.first = Button_Face_Tree_Full_Path_Name::Get(tr,it);
        result.second.it = it;
        result.second.pos = current_pos;
        path_positions.insert(result);
        
        return Should_Break::NO;
    });
    
    
    return path_positions;
❱


◀private: static▶ Frame_Elements  ☀Build_Branches_And_Button_Labels(Character_Maps const& font_chars, Pc_Input_State const& pc_input, Position const& pos, const tree<Buttoned_Faced_Label>& tr, Button_Face_Tree_Range const& range)❰
    
    auto start_pos = pos;
    auto current_pos = pos;
    
    Frame_Elements all;
    Frame_Elements branches;
    Frame_Elements labels;
    
    For_Each_Noncollapsed::Iterate(tr,range.begin,range.end,[&](tree<Buttoned_Faced_Label>::pre_order_iterator it, int depth){
        
        //branches
        Append(branches.types,Possibly_Add_Branches(tr,it,it->label,start_pos,current_pos,depth).types);
        
        //adjust position for label.  perform event update.
        Adjust_Positions_For_Next_Cell(it->label,start_pos,current_pos,depth);
        Faced_Label_Eventer::Event_It(font_chars,it->label,current_pos,pc_input);
        
        //should we show the button
        it->style.show_button = tr.number_of_children(it) > 0;
        
        //draw the label
        Append(labels.types,Buttoned_Faced_Label_Drawer::Draw(font_chars,*it,current_pos,pc_input).types);
        
        return Should_Break::NO;
    });
    
    all.types += branches.types;
    all.types += labels.types;
    return all;
❱

◀private: static▶ Frame_Elements  ☀Possibly_Add_Branches(tree<Buttoned_Faced_Label> const& tr, tree<Buttoned_Faced_Label>::pre_order_iterator it, Faced_Label const& label, Position const& start_pos, Position const& current_pos, int const& depth)❰

    Frame_Elements elements;
    
    auto dim = Faced_Label_Drawer::Get_Dimensions(label);

    Positioned_Multi_Color_Bitmap branch_data;
    branch_data.bitmap = Vertical_Line::Create(14);
    branch_data.pos.x = start_pos.x;
    branch_data.pos.y = current_pos.y + dim.y-7;
    for (size_t i = 0; i < depth; ++i){
        
        
        if (Should_Put_Vertical_Bar(tr,it,i)){
            branch_data.pos.x = start_pos.x + (10 * i) - 16;
            elements.types.emplace_back(branch_data);
        }
    }
    
    if (depth != 0){
        branch_data.bitmap = L_Line::Create(14,11);
        branch_data.pos.x = start_pos.x + (10 * depth) - 16;
        branch_data.pos.y = current_pos.y + dim.y-7;
        elements.types.emplace_back(branch_data);
    }
    
    //add selector arrow
    if (Faced_Label_Is_Active::Is_Active(label)){
        branch_data.bitmap = Right_Arrow::Create(10);
        branch_data.pos.x = start_pos.x - 18;
        branch_data.pos.y = current_pos.y + 16;
        elements.types.emplace_back(branch_data);
    }
    
    return elements;
    
❱

◀private: static▶ bool  ☀Should_Put_Vertical_Bar(tree<Buttoned_Faced_Label> const& tr, tree<Buttoned_Faced_Label>::pre_order_iterator it, int depth)❰

    auto current_depth = tr.depth(it);
    auto ptr = it;
    for (int i = depth; i < current_depth; ++i){
        ptr = tr.parent(ptr);
    }
    
    bool another_parent_child = (tr.next_sibling(ptr) != nullptr);
    return another_parent_child;
❱


◀private: static▶ void  ☀Adjust_Positions_For_Next_Cell(Faced_Label const& label, Position const& start_pos, Position & current_pos, int const& depth)❰
        auto dim = Faced_Label_Drawer::Get_Dimensions(label);
        current_pos.x = start_pos.x + 10 * depth;
        current_pos.y += dim.y-1;
❱
