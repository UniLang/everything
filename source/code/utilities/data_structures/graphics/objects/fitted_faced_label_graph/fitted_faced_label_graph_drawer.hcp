class
❪string❫
❪cmath❫
❪"code/utilities/data_structures/graphics/objects/faced_label/data/faced_label"❫
❪"code/utilities/data_structures/graph/conceptually_laid_out_graph/conceptually_laid_out_graph"❫
❪"code/utilities/data_structures/graphics/objects/fitted_faced_label_graph/data/fitted_faced_label_graph"❫
❪"code/utilities/data_structures/graphics/objects/fitted_faced_label_graph/data/positioned_fitted_faced_label_graph"❫
❪"code/utilities/data_structures/graphics/objects/faced_label/premade/faced_label_premades"❫
❪"code/utilities/data_structures/graphics/objects/frame_elements"❫
❪"code/utilities/peripheral/mouse/state/mouse_state"❫
❪"code/utilities/fonts/bdf/character_maps/character_maps"❫
⚯
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/data_structures/graphics/objects/faced_label/faced_label_drawer"❫
⚞⚟


◀public: static▶ Frame_Elements ☀Full_Draw(Character_Maps const& font_chars, Positioned_Fitted_Faced_Label_Graph const& x, Pc_Input_State const& pc_input)
❰
    return Full_Draw(font_chars,x.state,x.pos,pc_input);
❱

◀public: static▶ Frame_Elements ☀Full_Draw(Character_Maps const& font_chars, Fitted_Faced_Label_Graph_State const& x, Position const& pos, Pc_Input_State const& pc_input)
❰
    Frame_Elements elements;
    
    int height_buffer = 20;
    int width_buffer = 10;

    //find biggest pos.x (so we know when were done)
    int max_pos_x = Get_Conceptual_Max_Pos_X(x);


    //construct individually positioned nodes based on their conceptual layout but with their actual pixel layout
    std::vector<Positioned_Faced_Label> drawable_labels;
    for (size_t column = 0; column < max_pos_x; ++column){
        
        
        //add all the column nodes
        auto column_nodes = Get_Concept_Nodes_By_Column(x,column);
        for (auto const& column_node: column_nodes){
            
            Positioned_Faced_Label temp;
            temp.state = column_node.state;
            temp.pos = pos;
            temp.pos.y += column_node.pos.y * height_buffer;
            drawable_labels.emplace_back(temp);
        }
        
        
        //calculate the width of this newly filled column
        //and adjust the positioning for the next column
        int new_column_width = 0;
        for (auto const& column_node: column_nodes){
            new_column_width = std::max(new_column_width,Faced_Label_Dimension_Getter::Get(column_node).x);
        }
        
        pos.x += new_solumn_width + width_buffer;
        
    }
    
    
    //not that we have all the nodes to draw, draw them
    for (auto const& it: drawable_labels){
        elements.types += Faced_Label_Drawer::Draw(font_chars,it,pc_input.mouse);
    }
    
    return elements;
❱



◀private: static▶ int ☀Get_Conceptual_Max_Pos_X(Fitted_Faced_Label_Graph_State const& x)❰

    int result = 0;
    for (auto const& it: x.concept.nodes){
        result = std::max(result,it.pos.x);
    }
    return result;
❱

◀private: static▶ std::vector<Positioned_Faced_Label>  ☀Get_Concept_Nodes_By_Column(Fitted_Faced_Label_Graph_State const& x, int column)❰

    std::vector<Positioned_Faced_Label> labels;
    for (auto const& it: x.concept.nodes){
        if (it.pos.x == column){
            Positioned_Faced_Label temp;
            temp.state = it.state;
            temp.state.pos = it.pos;
            labels.emplace_back(it);
        }
    }
    return labels;
❱