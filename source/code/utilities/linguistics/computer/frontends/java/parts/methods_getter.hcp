class

❪fstream❫
❪iostream❫
❪"code/utilities/contributor/contributor"❫
❪"code/utilities/code/concept_static_tree_structs"❫
❪"code/utilities/linguistics/computer/frontends/java/settings/java_settings"❫

⚯
❪"code/utilities/comments/doxygen/maker/doxygen_block_printer"❫
❪"code/utilities/linguistics/computer/keywords/visibility/visibility_keyword_getter"❫
❪"code/utilities/code/query/data_member_visibility"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/vectors/converters/lib"❫
⚞⚟

◀public: static▶ std::string ☀Get(model::Module const& structure, std::vector<Contributor> const& contributors, Java_Settings const& settings)❰
    std::string x;
    
    
    for (auto it: structure.function){
         x += Doxygen_Block_Printer::Get_Indented_Block(it,structure.function,settings.module,4);
         x += "\n";
         x += Get_Signature(First_Element_Or_Default(structure.module_name).value,it,settings);
         x += "\n";
         x += Get_Possible_Body(it,settings);
    }
    
    return x;
❱

◀private: static▶ std::string ☀Get_Possible_Body(model::Function const& method, Java_Settings const& settings)❰
    std::string x;
    
    //regular methods have a body
    if (!Method_Is_Abstract(method)){
        x += "{\n";
        x += Get_Body(method,settings);
        x += "\n}\n";
    }
    
    //abstract methods do not have a body
    else{
        x += ";";
    }
    
    return x;
❱

◀private: static▶ std::string ☀Get_Signature(std::string const& name, model::Function const& method, Java_Settings const& settings)❰

    
    std::string x;
     x += Possibly_Get_Static_Keyword(method,settings);
     x += " ";
     x += Possibly_Get_Abstract_Keyword(method,settings);
     x += " ";
     x += Get_Visibility_Specifiers(method);
     x += " ";
     x += Function_Template_Getter(method);
     x += " ";
    // x += Return_Type_Str_Getter::Get_Java(name,method,settings);
     x += " ";
    // x += Shared_Printer::Derive_Function_Name(name,Code_Type::PRODUCT_TYPE,method,bad_temp);
     x += Get_Arguments(method,settings);
     x += Possible_Thrown_Exceptions(method,settings);
    
    
    return x;
❱

◀private: static▶ std::string ☀Get_Visibility_Specifiers(model::Function const& method)❰
    // auto x = Data_Member_Visibility::Get(mem);
    // return Visibility_Keyword_Getter::Get(x,Source_Language::JAVA);
    return "";
❱

◀private: static▶ std::string ☀Function_Template_Getter(model::Function const& method)❰
    std::string x;
    //x += Get_Template_Syntax(method.template_arguments);
    return x;
❱

◀private: static▶ std::string ☀Get_Template_Syntax(std::vector<model::FunctionTemplateArgument> const& type_specializations)❰
    std::string special;
    
    // if (!type_specializations.empty()){
    //     special += "<";
    // }
    
    // for (auto const& it: type_specializations){
    //         special += as_string(it.identifier.value);
    //     }
        
    // if (!type_specializations.empty()){
    //     special += ">";
    // }
    return special;
❱

◀private: static▶ std::string ☀Get_Arguments(model::Function const& method, Java_Settings const& settings)❰
    std::string x;
    // x += "(";
    //     Call_Function_On_All_Elements_Except_Last_Element_Then_Call_Function_On_Last_Element(method.function_arguments
    //      ,[&](model::FunctionArgument arg){
            
    //        x += Get_Printable_Argument(arg,settings);
    //        x += ", ";
    //      }
    //      ,[&](model::FunctionArgument arg){
    //        x += Get_Printable_Argument(arg,settings);
    //      });
        
    // x += ")";
    return x;
❱

◀private: static▶ std::string ☀Possible_Thrown_Exceptions(model::Function const& method, Java_Settings const& settings)❰
    std::string x;
    
    // auto expression = as_string(method.exception_expression.value);
    // if (!expression.empty()){
    //     x+= " throws " + expression;
    // }
    
    return x;
❱


◀private: static▶ std::string ☀Get_Printable_Argument(model::FunctionArgument const& arg, Java_Settings const& settings)❰

    
    std::string x;
    
   // auto type = as_string(arg.type.value);
   // auto real_type = Type_Name_Deriver::Derive_Name(arg,Source_Language::JAVA);
   //  x += real_type;
   //  x += " ";
   //  x += Identifier_Name_Deriver::Derive_Name(arg,bad_temp);
    return x;
❱

◀private: static▶ std::string ☀Possibly_Get_Static_Keyword(model::Function const& method, Java_Settings const& settings)❰
      
      std::string x;
      
    // //TODO: MOVE OUT
    // std::string static_keyword = "static";
    // std::string static_keyword_spacer = " ";
     
    //  //static qualifier
    //  if (method.storage == Storage_Specifier::STATIC){
    //     Append(x,static_keyword);
    //     Append(x,static_keyword_spacer);
    //  }
     return x;
❱
◀private: static▶ std::string ☀Possibly_Get_Abstract_Keyword(model::Function const& method, Java_Settings const& settings)❰
      
      std::string x;
      
    // //TODO: MOVE OUT
    // std::string keyword = "abstract";
    // std::string keyword_spacer = " ";
     
    //  //static qualifier
    //  if (Method_Is_Abstract(method)){
    //     Append(x,keyword);
    //     Append(x,keyword_spacer);
    //  }
     return x;
❱

◀private: static▶ bool ☀Method_Is_Abstract(model::Function const& method)❰
    // if (method.inheritence.virtuality == Method_Virtuality::UNPURE_VIRTUAL || method.inheritence.virtuality == Method_Virtuality::PURE_VIRTUAL){
    //     return true;
    // }
    return false;
❱



◀private: static▶ std::string ☀Get_Body(model::Function const& method, Java_Settings const& settings)❰
    std::string x;
    // for (auto const& it: method.body){
    //     x += as_string(it.value);
    // }
    return x;
❱