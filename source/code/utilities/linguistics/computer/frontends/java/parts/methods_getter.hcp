class

❪fstream❫
❪iostream❫
❪"code/utilities/contributor/contributor"❫
❪"code/utilities/code/concept_static_tree_structs"❫
❪"code/utilities/linguistics/computer/frontends/java/settings/java_settings"❫

⚯
❪"code/utilities/comments/doxygen/maker/doxygen_block_printer"❫
❪"code/utilities/linguistics/computer/keywords/visibility/visibility_keyword_getter"❫
❪"code/utilities/code/query/function_visibility"❫
❪"code/utilities/code/query/data_member_visibility"❫
❪"code/utilities/code/query/function_return_type_getter"❫
❪"code/utilities/code/query/virtual_method_checker"❫
❪"code/utilities/code/query/function_storage_specifier"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/vectors/operators/lib"❫
❪"code/utilities/types/vectors/converters/lib"❫
❪"code/utilities/types/general/lib"❫
❪"code/utilities/linguistics/computer/frontends/parts/identifier/function_name_getter"❫
❪"code/utilities/linguistics/computer/frontends/parts/identifier/function_argument_to_identifier"❫
❪"code/utilities/linguistics/computer/types/generic/type_name_deriver"❫
❪"code/utilities/types/strings/transformers/appending/lib"❫
⚞⚟

◀public: static▶ std::string ☀Get(model::Module const& structure, std::vector<Contributor> const& contributors, Java_Settings const& settings)❰
    std::string x;
    
    
    for (auto it: structure.function){
         x += Doxygen_Block_Printer::Get_Indented_Block(it,structure.function,settings.module,4);
         x += "\n";
         x += Get_Signature(First_Element_Or_Default(structure.name).value,it,settings);
         x += "\n";
         x += Get_Possible_Body(it,settings);
    }
    
    return x;
❱

◀private: static▶ std::string ☀Get_Possible_Body(model::Function const& method, Java_Settings const& settings)❰
    std::string x;
    
    //non-abstract methods have a body
    if (!Virtual_Method_Checker::Is_Virtual(method)){
        x += "{\n";
        x += Get_Body(method,settings);
        x += "\n}\n";
    }
    
    //abstract methods do not have a body
    else{
        x += ";";
    }
    
    return x;
❱

◀private: static▶ std::string ☀Get_Signature(std::string const& name, model::Function const& method, Java_Settings const& settings)❰

    
    std::string x;
     x += Possibly_Get_Static_Keyword(method,settings);
     x += " ";
     x += Possibly_Get_Abstract_Keyword(method,settings);
     x += " ";
     x += Get_Visibility_Specifiers(method);
     x += " ";
     x += Function_Template_Getter(method);
     x += " ";
     x += Function_Return_Type_Getter::Get_Real_Type(method,Source_Language::JAVA);
     x += " ";
     x += Function_Name_Getter::Derive_Function_Name(method,settings.module);
     x += Get_Argument_List(method,settings);
     x += Possible_Thrown_Exceptions(method,settings);
    
    
    return x;
❱

◀private: static▶ std::string ☀Get_Visibility_Specifiers(model::Function const& method)❰
    auto x = Function_Visibility::Get(method);
    return Visibility_Keyword_Getter::Get(x,Source_Language::JAVA);
❱

◀private: static▶ std::string ☀Function_Template_Getter(model::Function const& method)❰
    std::string x;
    x += Get_Template_Syntax(method.template_argument);
    return x;
❱

◀private: static▶ std::string ☀Get_Template_Syntax(std::vector<model::FunctionTemplateArgument> const& type_specializations)❰
    std::string special;
    
    if (!type_specializations.empty()){
        special += "<";
    }
    
    for (auto const& it: type_specializations){
            special += First_Element_Or_Default(it.identifier).value;
        }
        
    if (!type_specializations.empty()){
        special += ">";
    }
    return special;
❱

◀private: static▶ std::string ☀Get_Argument_List(model::Function const& method, Java_Settings const& settings)❰
    std::string x;
    x += "(";
        Call_Function_On_All_Elements_Except_Last_Element_Then_Call_Function_On_Last_Element(method.argument
         ,[&](model::FunctionArgument arg){
            
           x += Get_Printable_Argument(arg,settings);
           x += ", ";
         }
         ,[&](model::FunctionArgument arg){
           x += Get_Printable_Argument(arg,settings);
         });
        
    x += ")";
    return x;
❱

◀private: static▶ std::string ☀Possible_Thrown_Exceptions(model::Function const& method, Java_Settings const& settings)❰
    std::string x;
    
    auto expression = First_Element_Or_Default(First_Element_Or_Default(method.except).statement).value;
    if (!expression.empty()){
        x+= " throws " + expression;
    }
    
    return x;
❱


◀private: static▶ std::string ☀Get_Printable_Argument(model::FunctionArgument const& arg, Java_Settings const& settings)❰

    
    std::string x;
    
   auto real_type = Type_Name_Deriver::Derive_Name(arg,Source_Language::JAVA);
    x += real_type;
    x += " ";
    x += Function_Argument_To_Identifier::Derive_Name(arg,settings.module.portion);
    return x;
❱

◀private: static▶ std::string ☀Possibly_Get_Static_Keyword(model::Function const& method, Java_Settings const& settings)❰
      
      std::string x;
      
    //TODO: MOVE OUT
    std::string static_keyword = "static";
    std::string static_keyword_spacer = " ";
     
     //static qualifier
     if (Function_Storage_Specifier::Get(method) == Storage_Specifier::STATIC){
        Append(x,static_keyword);
        Append(x,static_keyword_spacer);
     }
     return x;
❱
◀private: static▶ std::string ☀Possibly_Get_Abstract_Keyword(model::Function const& method, Java_Settings const& settings)❰
      
      std::string x;
      
    // //TODO: MOVE OUT
    // std::string keyword = "abstract";
    // std::string keyword_spacer = " ";
     
    //  //static qualifier
    //  if (Method_Is_Abstract(method)){
    //     Append(x,keyword);
    //     Append(x,keyword_spacer);
    //  }
     return x;
❱



◀private: static▶ std::string ☀Get_Body(model::Function const& method, Java_Settings const& settings)❰
    std::string x;
    // for (auto const& it: method.body){
    //     x += as_string(it.value);
    // }
    return x;
❱