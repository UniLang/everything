class
❪string❫
❪iostream❫
❪algorithm❫
❪random❫
❪thread❫
❪unordered_set❫
❪utility❫
❪"include/crow.h"❫
❪"code/utilities/program/call/lib.hpp"❫
❪"code/utilities/data_structures/playing_card"❫
❪"code/programs/games/sequence/data/game_state"❫
⚯
❪"code/utilities/formats/html/basic_html_template_getter"❫
❪"code/utilities/assets/playing_card_assets"❫
❪"code/utilities/image/data_uri_getter"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
❪"code/utilities/types/strings/observers/splitting/lib"❫
⚞⚟

◀public: static▶ void ☀Run()❰
 
    
    Game_State game;
    game.host = "192.168.0.137";
    game.port = 18080;
    
    New_Game(game);
    
    
    
    
    //add routes and web sockets
    Create_Player_Routes_P1(game,game.p1);
    Create_Player_Routes_P2(game,game.p2);
    

    
    
    //start server
    game.server.port(game.port).multithreaded().run();
    
❱

◀private: static▶ void  ☀New_Game(Game_State & game)❰

    //build the board and the deck
    game.board = Get_Board();
    game.deck = Get_Deck();
    
    //each user draws 7 cards
    game.p1.websocket_name = "ws_p1";
    game.p1.player_num = 0;
    game.p1.hand.clear();
    for (size_t i = 0; i < 7; ++i){
        Transfer_An_Element(game.deck,game.p1.hand);
    }
    
    
    game.p2.websocket_name = "ws_p2";
    game.p2.player_num = 1;
    game.p2.hand.clear();
    for (size_t i = 0; i < 7; ++i){
        Transfer_An_Element(game.deck,game.p2.hand);
    }
    
    
    //decide who goes first
    game.player_turn = game.starting_player_turn;
    
    
    //cycle who goes first next time
    if (starting_player_turn == 0){
        starting_player_turn = 1;
    }
    else {
        starting_player_turn = 0;
    }

❱

◀private: static▶ void  ☀Create_Player_Routes_P1(Game_State & game, Player_State & state)❰

    CROW_ROUTE(game.server, "/ws_p1") //can't be dynamic :(
        .websocket()
        .onopen([&](crow::websocket::connection& conn){
                CROW_LOG_INFO << "new websocket connection";
                state.connection = &conn;
                })
        .onclose([&](crow::websocket::connection& conn, const std::string& reason){
                CROW_LOG_INFO << "websocket connection closed: " << reason;
                state.connection = nullptr;
                })
        .onmessage([&](crow::websocket::connection& conn, const std::string& data, bool is_binary){
            std::lock_guard<std::mutex> _(game.mtx);
                    std::cout << "UPDATE" << std::endl;
                    Update_Game_State(game,data,0);
                });
        
    CROW_ROUTE(game.server, "/p1")([&](){
        return Player1_Draw(game);
    });
❱

◀private: static▶ void  ☀Create_Player_Routes_P2(Game_State & game, Player_State & state)❰

    CROW_ROUTE(game.server, "/ws_p2") //can't be dynamic :(
        .websocket()
        .onopen([&](crow::websocket::connection& conn){
                CROW_LOG_INFO << "new websocket connection";
                state.connection = &conn;
                })
        .onclose([&](crow::websocket::connection& conn, const std::string& reason){
                CROW_LOG_INFO << "websocket connection closed: " << reason;
                state.connection = nullptr;
                })
        .onmessage([&](crow::websocket::connection& conn, const std::string& data, bool is_binary){
            std::lock_guard<std::mutex> _(game.mtx);
            std::cout << "UPDATE" << std::endl;
                    Update_Game_State(game,data,1);
                });
        
    CROW_ROUTE(game.server, "/p2")([&](){
        return Player2_Draw(game);
    });
❱






◀private: static▶ void  ☀Update_Game_State(Game_State & game, std::string const& data, int player)❰

    
    //update game state
    if (player == 0){
        Handle_Card_Select(game.p1,data);
        if (game.player_turn == 0){
            bool success = Take_Turn(game,game.p1,data);
            if (success) {
                game.player_turn = 1;
            }
        }
    }
    if (player == 1){
        Handle_Card_Select(game.p2,data);
        if (game.player_turn == 1){
            bool success = Take_Turn(game,game.p2,data);
            if (success) {
                game.player_turn = 0;
            }
        }
    }
    
    if (data == "new_game"){
        New_Game(game);
    }




    //redraw scene
    auto space1 = Get_Update_Space(game,game.p1);
    auto space2 = Get_Update_Space(game,game.p2);
    if (game.p1.connection) {
        game.p1.connection->send_text(space1);
    }
    if (game.p2.connection) {
        game.p2.connection->send_text(space2);
    }
❱

◀private: static▶ void  ☀Handle_Card_Select(Player_State & state, std::string const& data)❰

        if (Begins_With(data,"card")){
            std::string number = data;
            number.erase(0,4);
            int selected = std::atoi(number.c_str());
            if (state.card_selected == selected){
                state.card_selected = -1;
            }
            else {
                state.card_selected = selected;
            }
        }
❱

◀private: static▶ bool  ☀Take_Turn(Game_State & game, Player_State & state, std::string const& data)❰

    if (Begins_With(data,"space")){
            std::string number = data;
            number.erase(0,5);
            auto parts = Split_Into_Parts_From_Dash(number);
            auto index1 = std::atoi(parts[0].c_str());
            auto index2 = std::atoi(parts[1].c_str());
            std::cout << index1 << " " << index2 << std::endl;
            if (Is_Valid_Move(game,state,index1,index2)){
                Make_Move(game,state,index1,index2);
                return true;
            }
    }
    
    return false;
    std::cout << data << std::endl;
❱

◀private: static▶ bool  ☀Is_Valid_Move(Game_State & game, Player_State & state, int index1, int index2)❰
    if (state.card_selected == -1){
        return false;
    }
    
    auto selected_hand = state.hand[state.card_selected];
    auto selected_space = game.board[index1][index2];
    
    //handle 2 eye jacks
    if (Is_Add_Jack(selected_hand)){
        if (selected_space.value == -1){
            return true;
        }
        else{
            return false;
        }
    }
    
    //handle 1 eye jacks
    if (Is_Remove_Jack(selected_hand)){
        if (selected_space.value == -1){
            return false;
        }
        else {
            return true;
        }
    }
    
    //handle regular card
    if (selected_hand == selected_space.face){
        if (selected_space.value == -1){
            return true;
        }
    }
    
    return false;
    
❱

◀private: static▶ void  ☀Make_Move(Game_State & game, Player_State & state, int index1, int index2)❰
    
    auto selected_hand = state.hand[state.card_selected];
    
    //remove piece
    if (Is_Remove_Jack(selected_hand)){
        game.board[index1][index2].value = -1;
    }
    else {
    
        //add piece
        game.board[index1][index2].value = state.player_num;
    }
    
    //lose card
    Remove_Element(state.hand,selected_hand);
    state.card_selected = -1;
    
    //draw card from deck
    Transfer_An_Element(game.deck,state.hand);
❱



◀private: static▶ bool  ☀Is_Add_Jack(Playing_Card const& p)❰
    return p == Playing_Card::CARD_11_HEART || p == Playing_Card::CARD_11_DIAMOND;
❱
◀private: static▶ bool  ☀Is_Remove_Jack(Playing_Card const& p)❰
    return p == Playing_Card::CARD_11_SPADE || p == Playing_Card::CARD_11_CLOVER;
❱


//getting game state
◀private: static▶ std::vector<std::vector<Board_Space>>  ☀Get_Board()❰

    //get standard 52 deck
    auto cards = Playing_Card_all_enums();
    
    
    //shuffle
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(cards.begin(),cards.end(),g);
    
    //remove the jacks
    Remove_Element(cards,Playing_Card::CARD_11_CLOVER);
    Remove_Element(cards,Playing_Card::CARD_11_DIAMOND);
    Remove_Element(cards,Playing_Card::CARD_11_HEART);
    Remove_Element(cards,Playing_Card::CARD_11_SPADE);
    
    
    std::vector<Board_Space> spaces;
    for (auto const& it: cards){
        Board_Space temp;
        temp.face = it;
        spaces.emplace_back(temp);
    }
    
    
    auto board = Split_Every_N(spaces,6);
    return board;
    
❱

◀private: static▶ std::vector<Playing_Card>  ☀Get_Deck()❰

    //get standard 52 deck
    auto cards = Playing_Card_all_enums();
    
    //shuffle
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(cards.begin(),cards.end(),g);
    
    return cards;
❱











//drawing frontend
◀private: static▶ std::string ☀Player1_Draw(Game_State & game)❰

    return Player_Draw(game,game.p1);
❱

◀private: static▶ std::string ☀Player2_Draw(Game_State & game)❰

    return Player_Draw(game,game.p2);
❱


◀private: static▶ std::string ☀Player_Draw(Game_State & game, Player_State & player)❰

    //build boilerplate
    std::string title = "Sequence!";
    auto import_scripts = Get_Scripts();
    auto css = Get_Css();
    
    
    //build board
    auto ip = std::string("ws://") + game.host + ":" + std::to_string(game.port) + "/" + player.websocket_name;
    auto body = Everything_Update_Websocket(ip);
    body += "<div id='everything'>";
    body += Get_Update_Space(game,player);
    body += "</div>";

    //render
    return Basic_Html_Template_Getter::Get(title,import_scripts,css,body);
❱


◀private: static▶ std::string ☀Get_Update_Space(Game_State & game, Player_State & state)❰

    std::string body;
    body += Draw_Html_Board(game.board,state);
    body += Draw_Hand(game,state);
    body += Draw_Game_Status(game,state);
    //std::cout << body << std::endl;
    return body;
❱




◀private: static▶ std::vector<std::string> ☀Get_Scripts()❰
        std::vector<std::string> import_scripts;
    import_scripts.emplace_back("https://code.jquery.com/jquery-3.1.0.min.js");
    return import_scripts;
❱

◀private: static▶ std::string ☀Get_Css()❰

    std::string css;
    css +=  "img {  vertical-align: bottom; width: 50px; }";
    css +=  ".card_row { display: flex; }";
    css +=  ".hand { display: flex; }";
    css +=  ".card_selected {     padding: 4px; background: red; }";
    css +=  ".space_selected {     outline: 6px solid red; }";
    
    
    css += R"RAW_STRING(
        .p1-circle {
            width: 30px;
            height: 30px;
            margin-left: 9px;
            margin-top: 17px;
            position: absolute;
            background: red;
            border-radius: 50%;
        }
        
        .p2-circle {
            width: 30px;
            height: 30px;
            margin-left: 9px;
            margin-top: 17px;
            position: absolute;
            background: yellow;
            border-radius: 50%;
        }
        )RAW_STRING";
    
    
    return css;
❱

◀private: static▶ std::string ☀Everything_Update_Websocket(std::string const& socket_name)❰

    //establish the websocket
std::string body;

    body += "<script>";
    
    body += R"RAW_STRING(
    function on_click_handlers(sock) {
        
        $(".card0").on( "click", function() {
            console.log("card0");
            sock.send("card0");
        });
        $(".card1").on( "click", function() {
            console.log("card1");
            sock.send("card1");
        });
        $(".card2").on( "click", function() {
            console.log("card2");
            sock.send("card2");
        });
        $(".card3").on( "click", function() {
            console.log("card3");
            sock.send("card3");
        });
        $(".card4").on( "click", function() {
            console.log("card4");
            sock.send("card4");
        });
        $(".card5").on( "click", function() {
            console.log("card5");
            sock.send("card5");
        });
        $(".card6").on( "click", function() {
            console.log("card6");
            sock.send("card6");
        });
        
        $(".new_game").on( "click", function() {
            sock.send("new_game");
        });
)RAW_STRING";
    for (size_t i = 0; i < 8; ++i){
        for (size_t j = 0; j < 6; ++j){
            std::string space_name = "space";
            space_name += std::to_string(i) + "-" + std::to_string(j);
            
            body +="$(\".";
            body += space_name;
            body += "\")";
            body += ".on( \"click\", function() {";
            body += "sock.send(\"";
            body += space_name;
            body += "\");});\n";
        }
    }
    body += "}";
    
    body += "$(document).ready(function() {";
    
    body += "var sock = new WebSocket(\"";
    body += socket_name;
    body += "\");";
    
    
    body += R"RAW_STRING(

    sock.onopen = ()=>{
        console.log('open')
    }
    sock.onerror = (e)=>{
        console.log('error',e)
    }
    sock.onclose = ()=>{
        console.log('close')
    }
    sock.onmessage = (e)=>{
        console.log(e)
        $('#everything').html(e.data);
        on_click_handlers(sock);
    }
    )RAW_STRING";
    
    
    body += R"RAW_STRING(
        on_click_handlers(sock);
    )RAW_STRING";
    
    body += "});";
    
    
    
    
    body += "</script>";
    
    return body;
❱


◀private: static▶ std::string ☀Draw_Html_Board(std::vector<std::vector<Board_Space>> const& cards, Player_State & player)❰

    std::string body;
    
    
    int counter1 = 0;
    for (auto const& a: cards){
        body += "<div class='card_row'>";
        int counter2 = 0;
        for (auto const& card: a){
            body += "<div class='space" + std::to_string(counter1) + "-" + std::to_string(counter2) + " ";
            if (player.card_selected != -1){
                auto selected_face = player.hand[player.card_selected];
                if (selected_face == card.face){
                    body += " space_selected ";
                }
            }
            body += "'>";
            
            if (card.value == 0){
                body += "<div class='p1-circle'> </div>";
            }
            else if (card.value == 1){
                body += "<div class='p2-circle'> </div>";
            }
            body += Data_Uri_Getter::Get_Img_Tag(Playing_Card_Assets::Get(card.face));
            body += "</div>";
            ++counter2;
        }
        ++counter1;
        body += "</div>";
    }
    return body;
    
❱

◀private: static▶ std::string ☀Draw_Hand(Game_State & game, Player_State & state)❰

    //build hand
    std::string body;
    body += "<div class='hand'>";
    int counter = 0;
    for (auto const& card: state.hand){
        body += "<div class='card" + std::to_string(counter) + " ";
        if (state.card_selected == counter){
            body += " card_selected ";
        }
        body += "'>";
        body += Data_Uri_Getter::Get_Img_Tag(Playing_Card_Assets::Get(card));
        body += "</div>";
        counter++;
    }
    body += "</div>";
    return body;
❱

◀private: static▶ std::string ☀Draw_Game_Status(Game_State & game, Player_State & state)❰
    std::string body;
    if (game.player_turn == state.player_num){
        body += "Your turn";
    }
    body += "<p class='new_game'> [ new game ] </p>";
    return body;
❱









