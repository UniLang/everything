class
❪string❫
❪iostream❫
❪algorithm❫
❪random❫
❪thread❫
❪unordered_set❫
❪utility❫
❪"include/crow.h"❫
❪"code/utilities/program/call/lib.hpp"❫
❪"code/utilities/data_structures/playing_card"❫
❪"code/programs/games/sequence/data/game_state"❫
⚯
❪"code/utilities/formats/html/basic_html_template_getter"❫
❪"code/utilities/assets/playing_card_assets"❫
❪"code/utilities/image/data_uri_getter"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
⚞⚟

◀public: static▶ void ☀Run()❰
 
    
    Game_State game;
    game.port = 18080;
    
    //build the board and the deck
    game.board = Get_Board();
    game.deck = Get_Deck();
    
    //each user draws 7 cards
    game.p1.websocket_name = "ws_p1";
    for (size_t i = 0; i < 7; ++i){
        Transfer_An_Element(deck,game.p1.hand);
    }
    
    
    game.p2.websocket_name = "ws_p2";
    for (size_t i = 0; i < 7; ++i){
        Transfer_An_Element(deck,game.p2.hand);
    }
    
    
    
    
    //add routes and web sockets
    Create_Player_Routes_P1(game,game.p1);
    Create_Player_Routes_P2(game,game.p2);
    

    
    
    //start server
    game.server.port(game.port).multithreaded().run();
    
❱


◀private: static▶ void  ☀Create_Player_Routes_P1(Game_State & game, Player_State & state)❰

    CROW_ROUTE(game.server, "/ws_p1") //can't be dynamic :(
        .websocket()
        .onopen([&](crow::websocket::connection& conn){
                CROW_LOG_INFO << "new websocket connection";
                state.connection = &conn;
                })
        .onclose([&](crow::websocket::connection& conn, const std::string& reason){
                CROW_LOG_INFO << "websocket connection closed: " << reason;
                state.connection = nullptr;
                })
        .onmessage([&](crow::websocket::connection& conn, const std::string& data, bool is_binary){
                    Update_Game_State(game,data,0);
                });
        
    CROW_ROUTE(game.server, "/p1")([&](){
        return Player1_Draw(game);
    });
❱

◀private: static▶ void  ☀Create_Player_Routes_P2(Game_State & game, Player_State & state)❰

    CROW_ROUTE(game.server, "/ws_p2") //can't be dynamic :(
        .websocket()
        .onopen([&](crow::websocket::connection& conn){
                CROW_LOG_INFO << "new websocket connection";
                state.connection = &conn;
                })
        .onclose([&](crow::websocket::connection& conn, const std::string& reason){
                CROW_LOG_INFO << "websocket connection closed: " << reason;
                state.connection = nullptr;
                })
        .onmessage([&](crow::websocket::connection& conn, const std::string& data, bool is_binary){
                    Update_Game_State(game,data,1);
                });
        
    CROW_ROUTE(game.server, "/p2")([&](){
        return Player2_Draw(game);
    });
❱






◀private: static▶ void  ☀Update_Game_State(Game_State & game, std::string const& data, int player)❰

    // for (auto it: player1){
    //     it->send_text("test");
    // }
    // for (auto it: player2){
    //     it->send_text("test");
    // }
❱

◀private: static▶ std::vector<std::vector<Playing_Card>>  ☀Get_Board()❰

    //get standard 52 deck
    auto cards = Playing_Card_all_enums();
    
    std::cout << cards.size() << std::endl;
    
    //shuffle
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(cards.begin(),cards.end(),g);
    
    //remove the jacks
    Remove_Element(cards,Playing_Card::CARD_11_CLOVER);
    Remove_Element(cards,Playing_Card::CARD_11_DIAMOND);
    Remove_Element(cards,Playing_Card::CARD_11_HEART);
    Remove_Element(cards,Playing_Card::CARD_11_SPADE);
    
    std::cout << cards.size() << std::endl;
    
    auto board = Split_Every_N(cards,6);
    return board;
    
❱

◀private: static▶ std::vector<Playing_Card>  ☀Get_Deck()❰

    //get standard 52 deck
    auto cards = Playing_Card_all_enums();
    
    //shuffle
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(cards.begin(),cards.end(),g);
    
    return cards;
❱







◀private: static▶ std::string ☀Player1_Draw(Game_State & game)❰

    //build boilerplate
    std::string title = "Sequence!";
    auto import_scripts = Get_Scripts();
    auto css = Get_Css();
    
    
    //build board
    auto body = Everything_Update_Websocket("ws://192.168.0.137:18080/ws_p1");
    body += "<div id='everything'>";
    body += Get_Html_Board(game.board);
    body += "</div>";
    
    //build hand
    body += "<div class='hand'>";
    for (auto const& card: game.p1.hand){
        body += Data_Uri_Getter::Get_Img_Tag(Playing_Card_Assets::Get(card));
    }
    body += "</div>";

    //render
    return Basic_Html_Template_Getter::Get(title,import_scripts,css,body);
❱

◀private: static▶ std::string ☀Player2_Draw(Game_State & game)❰

    //build boilerplate
    std::string title = "Sequence!";
    auto import_scripts = Get_Scripts();
    auto css = Get_Css();
    
    
    //build board
    auto body = Everything_Update_Websocket("ws://192.168.0.137:18080/ws_p2");
    body += "<div id='everything'>";
    body += Get_Html_Board(game.board);
    body += "</div>";
    
    //build hand
    body += "<div class='hand'>";
    for (auto const& card: game.p2.hand){
        body += Data_Uri_Getter::Get_Img_Tag(Playing_Card_Assets::Get(card));
    }
    body += "</div>";

    //render
    return Basic_Html_Template_Getter::Get(title,import_scripts,css,body);
❱



◀private: static▶ std::vector<std::string> ☀Get_Scripts()❰
        std::vector<std::string> import_scripts;
    import_scripts.emplace_back("https://code.jquery.com/jquery-3.1.0.min.js");
    return import_scripts;
❱

◀private: static▶ std::string ☀Get_Css()❰

    std::string css;
    css +=  "img {  vertical-align: bottom; width: 50px; }";
    css +=  ".card_row { display: flex; }";
    return css;
❱



◀private: static▶ std::string ☀Everything_Update_Websocket(std::string const& socket_name)❰

    //establish the websocket
std::string body;

    body += "<script>";
    body += "var sock = new WebSocket(\"";
    body += socket_name;
    body += "\");";
    
    
    body += R"RAW_STRING(

    sock.onopen = ()=>{
        console.log('open')
    }
    sock.onerror = (e)=>{
        console.log('error',e)
    }
    sock.onclose = ()=>{
        console.log('close')
    }
    sock.onmessage = (e)=>{
        console.log(e)
        $('#everything').html(e.data);
    }
    </script>
    )RAW_STRING";
    
    return body;
❱



◀private: static▶ std::string ☀Get_Html_Board(std::vector<std::vector<Playing_Card>> const& cards)❰

    std::string body;
    
    
    for (auto const& a: cards){
        body += "<div class='card_row'>";
        for (auto const& card: a){
            body += Data_Uri_Getter::Get_Img_Tag(Playing_Card_Assets::Get(card));
        }
        body += "</div>";
    }
    return body;
    
❱









