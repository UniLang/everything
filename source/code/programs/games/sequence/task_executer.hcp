class
❪string❫
❪iostream❫
❪algorithm❫
❪random❫
❪thread❫
❪unordered_set❫
❪utility❫
❪"include/crow.h"❫
❪"code/utilities/program/call/lib.hpp"❫
❪"code/utilities/data_structures/playing_card"❫
❪"code/programs/games/sequence/data/game_state"❫
⚯
❪"code/utilities/formats/html/basic_html_template_getter"❫
❪"code/utilities/assets/playing_card_assets"❫
❪"code/utilities/image/data_uri_getter"❫
❪"code/utilities/types/vectors/transformers/lib"❫
❪"code/utilities/types/vectors/observers/lib"❫
❪"code/utilities/types/strings/observers/other/lib"❫
⚞⚟

◀public: static▶ void ☀Run()❰
 
    
    Game_State game;
    game.port = 18080;
    
    //build the board and the deck
    game.board = Get_Board();
    game.deck = Get_Deck();
    
    //each user draws 7 cards
    game.p1.websocket_name = "ws_p1";
    for (size_t i = 0; i < 7; ++i){
        Transfer_An_Element(game.deck,game.p1.hand);
    }
    
    
    game.p2.websocket_name = "ws_p2";
    for (size_t i = 0; i < 7; ++i){
        Transfer_An_Element(game.deck,game.p2.hand);
    }
    
    
    
    
    //add routes and web sockets
    Create_Player_Routes_P1(game,game.p1);
    Create_Player_Routes_P2(game,game.p2);
    

    
    
    //start server
    game.server.port(game.port).multithreaded().run();
    
❱


◀private: static▶ void  ☀Create_Player_Routes_P1(Game_State & game, Player_State & state)❰

    CROW_ROUTE(game.server, "/ws_p1") //can't be dynamic :(
        .websocket()
        .onopen([&](crow::websocket::connection& conn){
                CROW_LOG_INFO << "new websocket connection";
                state.connection = &conn;
                })
        .onclose([&](crow::websocket::connection& conn, const std::string& reason){
                CROW_LOG_INFO << "websocket connection closed: " << reason;
                state.connection = nullptr;
                })
        .onmessage([&](crow::websocket::connection& conn, const std::string& data, bool is_binary){
            std::lock_guard<std::mutex> _(game.mtx);
                    std::cout << "UPDATE" << std::endl;
                    Update_Game_State(game,data,0);
                });
        
    CROW_ROUTE(game.server, "/p1")([&](){
        return Player1_Draw(game);
    });
❱

◀private: static▶ void  ☀Create_Player_Routes_P2(Game_State & game, Player_State & state)❰

    CROW_ROUTE(game.server, "/ws_p2") //can't be dynamic :(
        .websocket()
        .onopen([&](crow::websocket::connection& conn){
                CROW_LOG_INFO << "new websocket connection";
                state.connection = &conn;
                })
        .onclose([&](crow::websocket::connection& conn, const std::string& reason){
                CROW_LOG_INFO << "websocket connection closed: " << reason;
                state.connection = nullptr;
                })
        .onmessage([&](crow::websocket::connection& conn, const std::string& data, bool is_binary){
            std::lock_guard<std::mutex> _(game.mtx);
            std::cout << "UPDATE" << std::endl;
                    Update_Game_State(game,data,1);
                });
        
    CROW_ROUTE(game.server, "/p2")([&](){
        return Player2_Draw(game);
    });
❱






◀private: static▶ void  ☀Update_Game_State(Game_State & game, std::string const& data, int player)❰

    
    //update game state
    if (player == 0){
        Handle_Card_Select(game.p1,data);
    }
    if (player == 1){
        Handle_Card_Select(game.p2,data);
    }




    //redraw scene
    auto space1 = Get_Update_Space(game,game.p1);
    auto space2 = Get_Update_Space(game,game.p2);
    if (game.p1.connection) {
        game.p1.connection->send_text(space1);
    }
    if (game.p2.connection) {
        game.p2.connection->send_text(space2);
    }
❱

◀private: static▶ void  ☀Handle_Card_Select(Player_State & state, std::string const& data)❰

        if (Begins_With(data,"card")){
            std::string number = data;
            number.erase(0,4);
            int selected = std::atoi(number.c_str());
            if (state.card_selected == selected){
                state.card_selected = -1;
            }
            else {
                state.card_selected = selected;
            }
        }
❱


//getting game state
◀private: static▶ std::vector<std::vector<Playing_Card>>  ☀Get_Board()❰

    //get standard 52 deck
    auto cards = Playing_Card_all_enums();
    
    std::cout << cards.size() << std::endl;
    
    //shuffle
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(cards.begin(),cards.end(),g);
    
    //remove the jacks
    Remove_Element(cards,Playing_Card::CARD_11_CLOVER);
    Remove_Element(cards,Playing_Card::CARD_11_DIAMOND);
    Remove_Element(cards,Playing_Card::CARD_11_HEART);
    Remove_Element(cards,Playing_Card::CARD_11_SPADE);
    
    std::cout << cards.size() << std::endl;
    
    auto board = Split_Every_N(cards,6);
    return board;
    
❱

◀private: static▶ std::vector<Playing_Card>  ☀Get_Deck()❰

    //get standard 52 deck
    auto cards = Playing_Card_all_enums();
    
    //shuffle
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(cards.begin(),cards.end(),g);
    
    return cards;
❱











//drawing frontend
◀private: static▶ std::string ☀Player1_Draw(Game_State & game)❰

    //build boilerplate
    std::string title = "Sequence!";
    auto import_scripts = Get_Scripts();
    auto css = Get_Css();
    
    
    //build board
    auto body = Everything_Update_Websocket("ws://192.168.0.137:18080/ws_p1");
    body += "<div id='everything'>";
    body += Get_Update_Space(game,game.p1);
    body += "</div>";
    

    //render
    return Basic_Html_Template_Getter::Get(title,import_scripts,css,body);
❱

◀private: static▶ std::string ☀Player2_Draw(Game_State & game)❰

    //build boilerplate
    std::string title = "Sequence!";
    auto import_scripts = Get_Scripts();
    auto css = Get_Css();
    
    
    //build board
    auto body = Everything_Update_Websocket("ws://192.168.0.137:18080/ws_p2");
    body += "<div id='everything'>";
    body += Get_Update_Space(game,game.p2);
    body += "</div>";

    //render
    return Basic_Html_Template_Getter::Get(title,import_scripts,css,body);
❱

◀private: static▶ std::string ☀Get_Update_Space(Game_State & game, Player_State & state)❰

    std::string body;
    body += Get_Html_Board(game.board);
    body += Draw_Hand(game,state);
    //std::cout << body << std::endl;
    return body;
❱


◀private: static▶ std::string ☀Draw_Hand(Game_State & game, Player_State & state)❰

    //build hand
    std::string body;
    body += "<div class='hand'>";
    int counter = 0;
    for (auto const& card: state.hand){
        body += "<div class='card" + std::to_string(counter) + " ";
        if (state.card_selected == counter){
            body += " card_selected ";
        }
        body += "'>";
        body += Data_Uri_Getter::Get_Img_Tag(Playing_Card_Assets::Get(card));
        body += "</div>";
        counter++;
    }
    body += "</div>";
    return body;
❱


◀private: static▶ std::vector<std::string> ☀Get_Scripts()❰
        std::vector<std::string> import_scripts;
    import_scripts.emplace_back("https://code.jquery.com/jquery-3.1.0.min.js");
    return import_scripts;
❱

◀private: static▶ std::string ☀Get_Css()❰

    std::string css;
    css +=  "img {  vertical-align: bottom; width: 50px; }";
    css +=  ".card_row { display: flex; }";
    css +=  ".hand { display: flex; }";
    css +=  ".card_selected {     padding: 4px; background: red; }";
    return css;
❱

◀private: static▶ std::string ☀Everything_Update_Websocket(std::string const& socket_name)❰

    //establish the websocket
std::string body;

    body += "<script>";
    body += "$(document).ready(function() {";
    
    body += "var sock = new WebSocket(\"";
    body += socket_name;
    body += "\");";
    
    
    body += R"RAW_STRING(

    sock.onopen = ()=>{
        console.log('open')
    }
    sock.onerror = (e)=>{
        console.log('error',e)
    }
    sock.onclose = ()=>{
        console.log('close')
    }
    sock.onmessage = (e)=>{
        console.log(e)
        $('#everything').html(e.data);
    }
    )RAW_STRING";
    
    
    body += R"RAW_STRING(
        $(".card0").click(()=>{
            sock.send("card0");
        });
        $(".card1").click(()=>{
            sock.send("card1");
        });
        $(".card2").click(()=>{
            sock.send("card2");
        });
        $(".card3").click(()=>{
            sock.send("card3");
        });
        $(".card4").click(()=>{
            sock.send("card4");
        });
        $(".card5").click(()=>{
            sock.send("card5");
        });
        $(".card6").click(()=>{
            sock.send("card6");
        });
    )RAW_STRING";
    
    body += "});";
    body += "</script>";
    
    return body;
❱


◀private: static▶ std::string ☀Get_Html_Board(std::vector<std::vector<Playing_Card>> const& cards)❰

    std::string body;
    
    
    for (auto const& a: cards){
        body += "<div class='card_row'>";
        for (auto const& card: a){
            body += Data_Uri_Getter::Get_Img_Tag(Playing_Card_Assets::Get(card));
        }
        body += "</div>";
    }
    return body;
    
❱









