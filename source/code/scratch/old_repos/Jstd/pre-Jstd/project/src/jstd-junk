            bool IsCharInString(const char & ch, const std::string & str);
			bool IsCharInString(const std::string & str, const char & ch);
			bool CharIsInString(const char & ch, const std::string & str);
			bool CharIsInString(const std::string & str, const char & ch);
			bool CharInString(const char & ch, const std::string & str);
			bool CharInString(const std::string & str, const char & ch);
			bool CharInStr(const char & ch, const std::string & str);
			bool CharInStr(const std::string & str, const char & ch);
			bool Is_Char_In_String(const char & ch, const std::string & str);
			bool Is_Char_In_String(const std::string & str, const char & ch);
			bool Char_Is_In_String(const char & ch, const std::string & str);
			bool Char_Is_In_String(const std::string & str, const char & ch);
			bool Char_In_String(const char & ch, const std::string & str);
			bool Char_In_String(const std::string & str, const char & ch);
			bool Char_In_Str(const char & ch, const std::string & str);
			bool Char_In_Str(const std::string & str, const char & ch);/**
			Check to see if a character exists in a string
			PRE: the parameters are: a character to search for and a string to search in
			POST: returns true if the character is found in the string- false if it is not
			NOTE: When the first instance of the character is found, the function immediately returns true */
			
			bool IsCharASCII(const char & ch);
			bool IsCharAValidASCII(const char & ch);
			bool IsCharOfValidASCII(const char & ch);
			bool CharIsASCII(const char & ch);
			bool CharIsAValidASCII(const char & ch);
			bool CharIsOfValidASCII(const char & ch);
			bool Is_Char_ASCII(const char & ch);
			bool Is_Char_A_Valid_ASCII(const char & ch);
			bool Is_Char_Of_Valid_ASCII(const char & ch);
			bool Char_Is_ASCII(const char & ch);
			bool Char_Is_A_Valid_ASCII(const char & ch);
			bool Char_Is_Of_Valid_ASCII(const char & ch);/**
			Check to see if the character is a valid ASCII character
			PRE: a character is passed in
			POST: true is returned if the character is a valid ASCII- false if it is not
			NOTE: A valid ASCII will numerically be between or including (0 - 127)
			Characteristically, the character will need to be between or including (NUL - DEL) */

			
			bool IsCharASymbol(const char & ch);
			bool IsCharSymbol(const char & ch);
			bool CharIsASymbol(const char & ch);
			bool CharIsSymbol(const char & ch);/**
			Check to see if the character is a symbol
			The symbols are: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
			PRE: a character is passed in
			POST: true is returned if the character is a symbol-false if it not */
			
			
			
			
			

//Changing Case
void Capitalize(char & ch);
void Lowercase(char & ch);

void CycleThroughASCIITable(char & ch);
void CycleThroughASCIITableBackwards(char & ch);
void CycleThroughASCIITable(char & ch, unsigned short skipcount);
void CycleThroughASCIITableBackwards(char & ch, unsigned short skipcount);

void CycleThroughVisibleCharacters(char & ch);
void CycleThroughVisibleCharactersBackwards(char & ch);
void CycleThroughVisibleCharacters(char & ch, unsigned short skipcount);
void CycleThroughVisibleCharactersBackwards(char & ch, unsigned short skipcount);

void CycleThroughUppercase(char & ch);
void CycleThroughUppercaseBackwards(char & ch);
void CycleThroughUppercase(char & ch, unsigned short skipcount);
void CycleThroughUppercaseBackwards(char & ch, unsigned short skipcount);

void CycleThroughLowercase(char & ch);
void CycleThroughLowercaseBackwards(char & ch);
void CycleThroughLowercase(char & ch, unsigned short skipcount);
void CycleThroughLowercaseBackwards(char & ch, unsigned short skipcount);

void CycleThroughAlpha(char & ch);
void CycleThroughAlphaBackwards(char & ch);
void CycleThroughAlpha(char & ch, unsigned short skipcount);
void CycleThroughAlphaBackwards(char & ch, unsigned short skipcount);

//void CycleThroughNumeric(char & ch);
//void CycleThroughNumericBackwards(char & ch);
//void CycleThroughNumeric(char & ch, const unsigned short & skipcount);
//void CycleThroughNumericBackwards(char & ch, const unsigned short & skipcount);

//void CycleThroughAlphanumeric(char & ch);
//void CycleThroughAlphanumericBackwards(char & ch);
//void CycleThroughAlphanumeric(char & ch, const unsigned short & skipcount);
//void CycleThroughAlphanumericBackwards(char & ch, const unsigned short & skipcount);
//void CycleThroughAlphameric(char & ch);
//void CycleThroughAlphamericBackwards(char & ch);
//void CycleThroughAlphameric(char & ch, const unsigned short & skipcount);
//void CycleThroughAlphamericBackwards(char & ch, const unsigned short & skipcount);

//void CycleThroughSymbols(char & ch);
//void CycleThroughSymbolsBackwards(char & ch);
//void CycleThroughSymbols(char & ch, const unsigned short & skipcount);
//void CycleThroughSymbolsBackwards(char & ch, const unsigned short & skipcount);

//void CycleThroughPunctutation(char & ch);
//void CycleThroughPunctutationBackwards(char & ch);
//void CycleThroughPunctutation(char & ch, const unsigned short & skipcount);
//void CycleThroughPunctutationBackwards(char & ch, const unsigned short & skipcount);

//void CycleThroughEvenNumbers(char & ch);
//void CycleThroughEvenNumbersBackwards(char & ch);
//void CycleThroughEvenNumbers(char & ch, const unsigned short & skipcount);
//void CycleThroughEvenNumbersBackwards(char & ch, const unsigned short & skipcount);

//void CycleThroughOddNumbers(char & ch);
//void CycleThroughOddNumbersBackwards(char & ch);
//void CycleThroughOddNumbers(char & ch, const unsigned short & skipcount);
//void CycleThroughOddNumbersBackwards(char & ch, const unsigned short & skipcount);

//void CycleThroughPrimeNumbers(char & ch);
//void CycleThroughPrimeNumbersBackwards(char & ch);
//void CycleThroughPrimeNumbers(char & ch, const unsigned short & skipcount);
//void CycleThroughPrimeNumbersBackwards(char & ch, const unsigned short & skipcount);

//void CycleThroughClosedShapeCharacters(char & ch);
//void CycleThroughClosedShapeCharactersBackwards(char & ch);
//void CycleThroughClosedShapeCharacters(char & ch, const unsigned short & skipcount);
//void CycleThroughClosedShapeCharactersBackwards(char & ch, const unsigned short & skipcount);



//Randomizing
//void RandomizeCharacter(char & ch);
//void RandomizeToAVisibleCharacter(char & ch);
//void RandomUppercase(char & ch);
//void RandomLowercase(char & ch);
//void RandomAlpha(char & ch);
//void RandomNumeric(char & ch);
//void RandomAlphanumeric(char & ch);
//void RandomAlphameric(char & ch);
//void RandomSymbol(char & ch);
//void RandomPunctuation(char & ch);
//void RandomEvenNumber(char & ch);
//void RandomOddNumber(char & ch);
//void RandomPrimeNumber(char & ch);
//void RandomClosedShapeCharacter(char & ch);


void Capitalize(char & ch){
	//if the character is not a lowercase letter, it will not be changed
	if (IsCharLowercase(ch) == true){ch-=32;}
	return;
}
void Lowercase(char & ch){
	//if the character is not an uppercase letter, it will not be changed
	if (IsCharUppercase(ch) == true){ch+=32;}
	return;
}
void CycleThroughASCIITable(char & ch){
	if (ch == 127){ch = 0;}       //avoids overflow and starts over at the beginning of the ASCII table
	else if (ch > 127){ch = 127;} //already overflowed ASCII value? set it to the last value of the table
	else if (ch < 0){ch = 0;}     //already underflowed ASCII value? set it to the first value of the table
	else{ch++;}                   //increment to the next character in the ASCII table
	return;
}
void CycleThroughASCIITableBackwards(char & ch){
	if (ch == 0){ch = 127;}       //avoids underflow and starts over at the end of the ASCII table
	else if (ch > 127){ch = 127;} //already overflowed ASCII value? set it to the last value of the table
	else if (ch < 0){ch = 0;}     //already underflowed ASCII value? set it to the first value of the table
	else{ch--;}                   //decrement to the next character in the ASCII table
	return;
}
void CycleThroughASCIITable(char & ch, unsigned short skipcount){
	
	if (ch > 127){ch = 127;} //already overflowed ASCII value? set it to the last value of the table
	else if (ch < 0){ch = 0;}//already underflowed ASCII value? set it to the first value of the table

	unsigned char ch2 = ch; //to avoid overflow

	//fix values of skipcount that are too high
	//(make it a smaller value that still skips the same amount)
	while (skipcount >= 126){skipcount-= 126;}
	
	ch2+=skipcount+1; //advance to the next character skipping the amount specified by skipcount

	//if the skipcount caused the character to overflow the ASCII table,
	//adjust the value so that it cycled properly
	if (ch2 > 127){ch2-= 127;}
	
	ch = ch2;
	
	return;
}
void CycleThroughASCIITableBackwards(char & ch, unsigned short skipcount){

	if (ch > 127){ch = 127;} //already overflowed ASCII value? set it to the last value of the table
	else if (ch < 0){ch = 0;}//already underflowed ASCII value? set it to the first value of the table

	//fix values of skipcount that are too high
	//(make it a smaller value that still skips the same amount)
	while (skipcount >= 126){skipcount-= 126;}

	ch--;; //advance to the previous character skipping the amount specified by skipcount
	ch = ch - skipcount;
	
	//if the skipcount caused the character to underflow the ASCII table,
	//adjust the value so that it cycled properly
	if (ch < 0){ch+= 127;}

	return;
}
void CycleThroughVisibleCharacters(char & ch){
	if (ch == 126){ch = 33;}       //avoids overflow and starts over at the beginning of the visible character ASCII table
	else if (ch > 126){ch = 126;}  //already overflowed visible ASCII value? set it to the last visible value of the table
	else if (ch < 33){ch = 33;}    //already underflowed visible ASCII value? set it to the first visible value of the table
	else{ch++;}                    //increment to the next character in the ASCII table
	return;
}
void CycleThroughVisibleCharactersBackwards(char & ch){
	if (ch == 33){ch = 126;}       //avoids underflow and starts over at the end of the visible character ASCII table
	else if (ch > 126){ch = 126;}  //already overflowed visible ASCII value? set it to the last visible value of the table
	else if (ch < 33){ch = 33;}    //already underflowed visible ASCII value? set it to the first visible value of the table
	else{ch--;}                    //decrement to the previous character in the ASCII table
	return;
}
void CycleThroughVisibleCharacters(char & ch, unsigned short skipcount){
	
	if (ch > 126){ch = 126;} //already overflowed visible ASCII value? set it to the last visible value of the table
	else if (ch < 33){ch = 33;}//already underflowed visible ASCII value? set it to the first visible value of the table
	//fix values of skipcount that are too high
	//(make it a smaller value that still skips the same amount)
	
	unsigned char ch2 = ch; //to avoid overflow

	while (skipcount >= 93){skipcount-= 93;}

	ch2+=skipcount+1; //advance to the next character skipping the amount specified by skipcount

	//if the skipcount caused the character to overflow the visible ASCII table,
	//adjust the value so that it cycled properly
	if (ch2 > 126){ch2-= 94;}
	
	ch = ch2;

	return;
}
void CycleThroughVisibleCharactersBackwards(char & ch, unsigned short skipcount){
	
	if (ch > 126){ch = 126;} //already overflowed visible ASCII value? set it to the last visible value of the table
	else if (ch < 33){ch = 33;}//already underflowed visible ASCII value? set it to the first visible value of the table

	//fix values of skipcount that are too high
	//(make it a smaller value that still skips the same amount)
	while (skipcount >= 93){skipcount-= 93;}

	ch--; //advance to the previous character skipping the amount specified by skipcount
	ch = ch - skipcount;

	//if the skipcount caused the character to underflow the visible ASCII table,
	//adjust the value so that it cycled properly
	if (ch < 33){ch+= 94;}

	return;
}
void CycleThroughUppercase(char & ch){
	if (ch == 90){ch = 65;}      //avoids overflow and starts over at the beginning of the uppercase table
	else if (ch > 90){ch = 90;}  //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 65){ch = 65;}  //already underflowed uppercase value? set it to the first uppercase value of the table
	else{ch++;}                  //increment to the next character in the ASCII table
	return;
}
void CycleThroughUppercaseBackwards(char & ch){
	if (ch == 65){ch = 90;}      //avoids underflow and starts over at the end of the visible character ASCII table
	else if (ch > 90){ch = 90;}  //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 65){ch = 65;}  //already underflowed uppercase value? set it to the first uppercase value of the table
	else{ch--;}                  //decrement to the previous character in the ASCII table
	return;
}
void CycleThroughUppercase(char & ch, unsigned short skipcount){

	if (ch > 90){ch = 90;}      //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 65){ch = 65;} //already underflowed uppercase value? set it to the first uppercase value of the table

	unsigned char ch2 = ch; //avoid overflow

	//fix values of skipcount that are too high
	//(make it a smaller value that still skips the same amount)
	while (skipcount >= 25){skipcount-= 25;}

	ch2+=skipcount+1; //advance to the next character skipping the amount specified by skipcount

	//if the skipcount caused the character to overflow the upercase ASCII table,
	//adjust the value so that it cycled properly
	while (ch2 > 90){ch2-= 26;}
	
	ch = ch2;

	return;
}
void CycleThroughUppercaseBackwards(char & ch, unsigned short skipcount){

	if (ch > 90){ch = 90;}      //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 65){ch = 65;} //already underflowed uppercase value? set it to the first uppercase value of the table

	//fix values of skipcount that are too high
	//(make it a smaller value that still skips the same amount)
	while (skipcount >= 25){skipcount-= 25;}

	ch--; //advance to the previous character skipping the amount specified by skipcount
	ch = ch - skipcount;

	//if the skipcount caused the character to underflow the visible ASCII table,
	//adjust the value so that it cycled properly
	while (ch < 65){ch+= 26;}

	return;
}
void CycleThroughLowercase(char & ch){
	if (ch == 122){ch = 97;}      //avoids overflow and starts over at the beginning of the uppercase table
	else if (ch > 122){ch = 122;}  //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 97){ch = 97;}  //already underflowed uppercase value? set it to the first uppercase value of the table
	else{ch++;}                  //increment to the next character in the ASCII table
	return;
}
void CycleThroughLowercaseBackwards(char & ch){
	if (ch == 97){ch = 122;}      //avoids underflow and starts over at the end of the visible character ASCII table
	else if (ch > 122){ch = 122;}  //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 97){ch = 97;}  //already underflowed uppercase value? set it to the first uppercase value of the table
	else{ch--;}                  //decrement to the previous character in the ASCII table
	return;
}
void CycleThroughLowercase(char & ch, unsigned short skipcount){

	if (ch > 122){ch = 122;}      //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 97){ch = 97;} //already underflowed uppercase value? set it to the first uppercase value of the table

	//fix values of skipcount that are too high
	//(make it a smaller value that still skips the same amount)
	while (skipcount >= 25){skipcount-= 25;}

	ch+=skipcount+1; //advance to the next character skipping the amount specified by skipcount

	//if the skipcount caused the character to overflow the upercase ASCII table,
	//adjust the value so that it cycled properly
	while (ch > 122){ch-= 26;}

	return;
}
void CycleThroughLowercaseBackwards(char & ch, unsigned short skipcount){

	if (ch > 122){ch = 122;}      //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 97){ch = 97;} //already underflowed uppercase value? set it to the first uppercase value of the table

	//fix values of skipcount that are too high
	//(make it a smaller value that still skips the same amount)
	while (skipcount >= 25){skipcount-= 25;}

	ch--; //advance to the previous character skipping the amount specified by skipcount
	ch = ch - skipcount;

	//if the skipcount caused the character to underflow the visible ASCII table,
	//adjust the value so that it cycled properly
	if (ch < 97){ch+= 26;}

	return;
}
void CycleThroughAlpha(char & ch){
	if (ch == 122){ch = 65;}      //avoids overflow and starts over at the beginning of the uppercase table
	else if (ch > 122){ch = 122;}  //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 65){ch = 65;}  //already underflowed uppercase value? set it to the first uppercase value of the table
	else if (ch >= 91 && ch <= 93){ch = 90;} //fix because it's not a letter
	else if (ch >= 94 && ch <= 96){ch = 97;} //fix because it's not a letter

	else{ch++;}                  //increment to the next character in the ASCII table
	if (ch == 91){ch = 97;} //skip characters in between capitals and lowercase letters
	return;
}
void CycleThroughAlphaBackwards(char & ch){
	if (ch == 65){ch = 122;}      //avoids overflow and starts over at the beginning of the uppercase table
	else if (ch > 122){ch = 122;}  //already overflowed uppercase value? set it to the last uppercase value of the table
	else if (ch < 65){ch = 65;}  //already underflowed uppercase value? set it to the first uppercase value of the table
	else if (ch >= 91 && ch <= 93){ch = 90;} //fix because it's not a letter
	else if (ch >= 94 && ch <= 96){ch = 97;} //fix because it's not a letter

	else{ch--;}                  //increment to the next character in the ASCII table
	if (ch == 96){ch = 90;} //skip characters in between capitals and lowercase letters
	return;
}



bool IsCharAClosedShape(const char & ch);
bool IsCharAnOpenShape(const char & ch);

bool IsCharAClosedShape(const char & ch){
	
	switch(ch){
		case '@':
		case '#':
		case '%':
		case '&':
		case '4':
		case '6':
		case '8':
		case '9':
		case '0':
		case 'Q':
		case 'R':
		case 'O':
		case 'P':
		case 'A':
		case 'D':
		case 'B':
		case 'q':
		case 'e':
		case 'o':
		case 'p':
		case 'a':
		case 'd':
		case 'g':
		case '$':
		case 'b': return true;
		default : return false;
	}
}
bool IsCharAnOpenShape(const char & ch){
	switch(ch){
		case '!':
		case '"':
		case '\'':
		case '(':
		case ')':
		case '*':
		case '+':
		case 44 :
		case '-':
		case '.':
		case '/':
		case '1':
		case '2':
		case '3':
		case '5':
		case '7':
		case ':':
		case ';':
		case '<':
		case '=':
		case '>':
		case '?':
		case 'C':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '[':
		case '\\':
		case ']':
		case '^':
		case '_':
		case '`':
		case 'c':
		case 'e':
		case 'f':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':
		case '{':
		case '|':
		case '}':
		case '~': return true;
		default : return false;
	}
}











